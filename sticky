diff --git a/group-coordinator/src/main/java/org/apache/kafka/coordinator/group/streams/TargetAssignmentBuilder.java b/group-coordinator/src/main/java/org/apache/kafka/coordinator/group/streams/TargetAssignmentBuilder.java
index c33a322bb0..b60967dc1f 100644
--- a/group-coordinator/src/main/java/org/apache/kafka/coordinator/group/streams/TargetAssignmentBuilder.java
+++ b/group-coordinator/src/main/java/org/apache/kafka/coordinator/group/streams/TargetAssignmentBuilder.java
@@ -306,8 +306,7 @@ public class TargetAssignmentBuilder {
             newGroupAssignment = assignor.assign(
                 new GroupSpecImpl(
                     Collections.unmodifiableMap(memberSpecs),
-                    new ArrayList<>(topology.subtopologies().keySet()),
-                        new HashMap<>()
+                    new ArrayList<>(topology.subtopologies().keySet())
                 ),
                 new TopologyMetadata(subscriptionMetadata, topology)
             );
diff --git a/group-coordinator/src/main/java/org/apache/kafka/coordinator/group/taskassignor/GroupSpec.java b/group-coordinator/src/main/java/org/apache/kafka/coordinator/group/taskassignor/GroupSpec.java
index 46b279416f..cb9c5f3e39 100644
--- a/group-coordinator/src/main/java/org/apache/kafka/coordinator/group/taskassignor/GroupSpec.java
+++ b/group-coordinator/src/main/java/org/apache/kafka/coordinator/group/taskassignor/GroupSpec.java
@@ -34,6 +34,4 @@ public interface GroupSpec {
      */
     List<String> subtopologies();
 
-    Map<String, String> assignmentConfigs();
-
 }
diff --git a/group-coordinator/src/main/java/org/apache/kafka/coordinator/group/taskassignor/GroupSpecImpl.java b/group-coordinator/src/main/java/org/apache/kafka/coordinator/group/taskassignor/GroupSpecImpl.java
index 29c84d7c38..e08acaa468 100644
--- a/group-coordinator/src/main/java/org/apache/kafka/coordinator/group/taskassignor/GroupSpecImpl.java
+++ b/group-coordinator/src/main/java/org/apache/kafka/coordinator/group/taskassignor/GroupSpecImpl.java
@@ -35,18 +35,14 @@ public class GroupSpecImpl implements GroupSpec {
      */
     private final List<String> subtopologies;
 
-    private final Map<String, String> assignmentConfigs;
-
     public GroupSpecImpl(
         Map<String, AssignmentMemberSpec> members,
-        List<String> subtopologies,
-        Map<String, String> assignmentConfigs
+        List<String> subtopologies
     ) {
         Objects.requireNonNull(members);
         Objects.requireNonNull(subtopologies);
         this.members = members;
         this.subtopologies = subtopologies;
-        this.assignmentConfigs = assignmentConfigs;
     }
 
     /**
@@ -62,10 +58,6 @@ public class GroupSpecImpl implements GroupSpec {
         return subtopologies;
     }
 
-    @Override
-    public Map<String, String> assignmentConfigs() {
-        return assignmentConfigs;
-    }
     @Override
     public boolean equals(final Object o) {
         if (this == o) {
diff --git a/group-coordinator/src/main/java/org/apache/kafka/coordinator/group/taskassignor/ProcessSpec.java b/group-coordinator/src/main/java/org/apache/kafka/coordinator/group/taskassignor/ProcessSpec.java
deleted file mode 100644
index 62a19d1afb..0000000000
--- a/group-coordinator/src/main/java/org/apache/kafka/coordinator/group/taskassignor/ProcessSpec.java
+++ /dev/null
@@ -1,120 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements. See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.kafka.coordinator.group.taskassignor;
-
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Map;
-import java.util.Set;
-
-public class ProcessSpec {
-    private final String processId;
-    private int capacity;
-    private double load;
-    private final Map<String, Integer> memberToTaskCounts;
-
-    private final Set<TaskId> assignedTasks;
-
-    ProcessSpec(String processId) {
-        this.processId = processId;
-        this.capacity = 0;
-        this.load = Double.MAX_VALUE;
-        this.assignedTasks = new HashSet<>();
-        this.memberToTaskCounts = new HashMap<>();
-    }
-
-
-    public String processId() {
-        return processId;
-    }
-
-    public int capacity() {
-        return capacity;
-    }
-
-    public int totalTaskCount() {
-        return assignedTasks.size();
-    }
-
-    public double load() {
-        return load;
-    }
-
-    public Map<String, Integer> memberToTaskCounts() {
-        return memberToTaskCounts;
-    }
-
-    public Set<TaskId> assignedTasks() {
-        return assignedTasks;
-    }
-
-    public void addTasks (String memberId, Map<String, Set<Integer>> newTasks) {
-        int taskCount = 0 ;
-        for (Map.Entry<String, Set<Integer>> entry : newTasks.entrySet()) {
-            String subtopologyId = entry.getKey();
-            for (Integer id : entry.getValue()) {
-                //todo maybe double check if one task is assigned two times?!
-                assignedTasks.add(new TaskId(subtopologyId, id));
-                taskCount ++;
-            }
-        }
-        memberToTaskCounts.put(memberId, memberToTaskCounts.get(memberId) + taskCount);
-        computeLoad();
-    }
-
-    public void addTask (String memberId, String subtopology, int taskId) {
-        assignedTasks.add(new TaskId(subtopology, taskId));
-        memberToTaskCounts.put(memberId, memberToTaskCounts.get(memberId) + 1);
-        computeLoad();
-    }
-
-    private void incrementCapacity () {
-        capacity ++;
-        computeLoad();
-    }
-    public void computeLoad () {
-        if (capacity <= 0 ) {
-            this.load = -1;
-        } else {
-            this.load = (double) assignedTasks.size() / capacity;
-        }
-    }
-
-    public void addMember(String member) {
-        this.memberToTaskCounts.put(member, 0);
-        incrementCapacity();
-    }
-
-    public boolean reachedCapacity() {
-        return assignedTasks.size() >= capacity;
-    }
-
-    public int compareTo (ProcessSpec other) {
-        int loadCompare = Double.compare(this.load, other.load());
-        if (loadCompare == 0) {
-            return Integer.compare(other.capacity, this.capacity);
-        }
-        return loadCompare;
-    }
-
-    public boolean hasTask (String subtopologyId, int partition) {
-        return assignedTasks.contains(new TaskId(subtopologyId, partition));
-    }
-
-
-
-}
diff --git a/group-coordinator/src/main/java/org/apache/kafka/coordinator/group/taskassignor/StickyAssignor.java b/group-coordinator/src/main/java/org/apache/kafka/coordinator/group/taskassignor/StickyAssignor.java
deleted file mode 100644
index 22d095a3fc..0000000000
--- a/group-coordinator/src/main/java/org/apache/kafka/coordinator/group/taskassignor/StickyAssignor.java
+++ /dev/null
@@ -1,527 +0,0 @@
-package org.apache.kafka.coordinator.group.taskassignor;
-
-
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import java.util.ArrayList;
-import java.util.Comparator;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.Set;
-import java.util.stream.Collectors;
-
-public class StickyAssignor implements TaskAssignor{
-
-    public static final String STICKY_ASSIGNOR_NAME = "sticky";
-    private final boolean mustPreserveActiveTaskAssignment;
-    private static final Logger log = LoggerFactory.getLogger(StickyAssignor.class);
-
-    // helper data structures:
-    Map<String, String[]> subtopologyToActiveMember = new HashMap<>();
-    private TaskPairs taskPairs;
-    Map<String, ProcessSpec> processIdToProcessSpec = new HashMap<>();
-    Map<String, String> memberIdToProcessId = new HashMap<>();
-    Map<String, String[]> subtopologyToPrevActiveMember = new HashMap<>();
-    Map<String, Set<String>[]> subtopologyToPrevStandbyMember = new HashMap<>();
-
-    int allTasks = 0;
-    int totalCapacity = 0;
-    int tasksPerThread = 0;
-
-    // results/outputs:
-
-    /**
-     * The standby assignments keyed by member id
-     */
-    Map<String, Map<String, Set<Integer>>> standbyTasksAssignments = new HashMap<>();
-
-    /**
-     * The active assignments keyed by member id
-     */
-    Map<String, Map<String, Set<Integer>>> activeTasksAssignments = new HashMap<>();
-
-
-    public StickyAssignor(boolean mustPreserveActiveTaskAssignment) {
-        this.mustPreserveActiveTaskAssignment = mustPreserveActiveTaskAssignment;
-    }
-
-    @Override
-    public String name() {
-        return STICKY_ASSIGNOR_NAME;
-    }
-
-    @Override
-    public GroupAssignment assign(GroupSpec groupSpec, TopologyDescriber topologyDescriber) throws TaskAssignorException {
-
-        initialize(groupSpec, topologyDescriber);
-        //active
-        assignActive(groupSpec);
-        //standby
-        assignStandby(groupSpec, topologyDescriber);
-        //warm-up
-        // ...
-        return buildGroupAssignment();
-    }
-
-    @SuppressWarnings({"unchecked"})
-    private void initialize(GroupSpec groupSpec, TopologyDescriber topologyDescriber) {
-
-        for (String subtopology : groupSpec.subtopologies()) {
-            int numberOfPartitions = topologyDescriber.numPartitions(subtopology);
-            allTasks += numberOfPartitions;
-
-            subtopologyToActiveMember.put(subtopology, new String[numberOfPartitions]);
-            subtopologyToPrevActiveMember.put(subtopology, new String[numberOfPartitions]);
-
-            HashSet<String>[] prevstandbyMembers = new HashSet[numberOfPartitions];
-            subtopologyToPrevStandbyMember.put(subtopology, prevstandbyMembers);
-        }
-
-        totalCapacity = groupSpec.members().size();
-        tasksPerThread = computeTasksPerThread(allTasks, totalCapacity);
-        taskPairs = new TaskPairs(allTasks * (allTasks - 1) / 2);
-
-        for (Map.Entry<String, AssignmentMemberSpec> memberEntry : groupSpec.members().entrySet()) {
-            final String memberId = memberEntry.getKey();
-            final AssignmentMemberSpec memberSpec = memberEntry.getValue();
-
-            memberIdToProcessId.put(memberId, memberSpec.processId());
-            processIdToProcessSpec.putIfAbsent(memberSpec.processId(), new ProcessSpec(memberSpec.processId()));
-            processIdToProcessSpec.get(memberSpec.processId()).addMember(memberId);
-
-
-            // prev active tasks
-            final Map<String, Set<Integer>> prevActiveTasks = new HashMap<>(memberSpec.activeTasks());
-            for (Map.Entry<String, Set<Integer>> entry : prevActiveTasks.entrySet()) {
-                final String subtopologyId = entry.getKey();
-                final Set<Integer> taskIds = entry.getValue();
-                final String[] activeMembers = subtopologyToPrevActiveMember.get(subtopologyId);
-                for (int taskId : taskIds) {
-                    if (taskId < activeMembers.length) {
-                        activeMembers[taskId] = memberId;
-                    }
-                }
-            }
-
-            // prev standby tasks
-            final Map<String, Set<Integer>> prevStandByTasks = new HashMap<>(memberSpec.standbyTasks());
-            for (Map.Entry<String, Set<Integer>> entry : prevStandByTasks.entrySet()) {
-                final String subtopologyId = entry.getKey();
-                final Set<Integer> taskIds = entry.getValue();
-                final Set<String>[] standbyMembers = subtopologyToPrevStandbyMember.get(subtopologyId);
-                for (int taskId : taskIds) {
-                    if (standbyMembers[taskId] == null) {
-                        standbyMembers[taskId] = new HashSet<>();
-                    }
-                    standbyMembers[taskId].add(memberId);
-                }
-            }
-        }
-    }
-
-    private GroupAssignment buildGroupAssignment() {
-        final Map<String, MemberAssignment> memberAssignments = new HashMap<>();
-
-        for (String memberId : activeTasksAssignments.keySet()) {
-            memberAssignments.put(memberId,
-                    new MemberAssignment(activeTasksAssignments.get(memberId),
-                            standbyTasksAssignments.getOrDefault(memberId, new HashMap<>()),
-                            new HashMap<>()));
-            standbyTasksAssignments.remove(memberId);
-        }
-
-        for (String memberId : standbyTasksAssignments.keySet()) {
-            memberAssignments.put(memberId,
-                    new MemberAssignment(new HashMap<>(),
-                            standbyTasksAssignments.get(memberId),
-                            new HashMap<>()));
-        }
-        return new GroupAssignment(memberAssignments);
-    }
-
-    private void assignActive(GroupSpec groupSpec) {
-
-        // 1. re-assigning existing active tasks to clients that previously had the same active tasks
-        for (Map.Entry<String, AssignmentMemberSpec> memberEntry : groupSpec.members().entrySet()) {
-            final String memberId = memberEntry.getKey();
-            final AssignmentMemberSpec memberSpec = memberEntry.getValue();
-
-            Map<String, Set<Integer>> activeTasks = new HashMap<>(memberSpec.activeTasks());
-            maybeRemoveExtraTasks(activeTasks);
-            activeTasksAssignments.put(memberId, activeTasks);
-            updateHelpers(memberId, activeTasks);
-            maybeUpdateTasksPerThread(activeTasks.values().stream().mapToInt(Set::size).sum());
-        }
-
-        // 2. re-assigning tasks to clients that previously have seen the same task (as standby task)
-        for (Map.Entry<String, String[]> entry : subtopologyToActiveMember.entrySet()) {
-            final String subtopologyId = entry.getKey();
-            final String[] memberIds = entry.getValue();
-            for (int taskId =0; taskId < memberIds.length; taskId ++) {
-                if (memberIds[taskId] == null) {
-                    Set<String> standbyMembers = subtopologyToPrevStandbyMember.get(subtopologyId)[taskId];
-                    if (standbyMembers != null) {
-                        final String standbyMemberWithLeastLoad = findMemberWithLeastLoad(standbyMembers, subtopologyId, taskId, true);
-                        if (standbyMemberWithLeastLoad != null) {
-                            memberIds[taskId] = standbyMemberWithLeastLoad;
-                            updateActiveTasksAssignments(standbyMemberWithLeastLoad, subtopologyId, taskId);
-                            updateHelpers(standbyMemberWithLeastLoad, subtopologyId, taskId);
-                        }
-                    }
-                }
-            }
-        }
-
-        // 3. assign any remaining unassigned tasks
-        for (Map.Entry<String, String[]> entry : subtopologyToActiveMember.entrySet()) {
-            final String subtopologyId = entry.getKey();
-            final String[] activeMembers = entry.getValue();
-            for (int i = 0; i < activeMembers.length; i++) {
-                if (activeMembers[i] == null) {
-                    String member = findMember(subtopologyId, i, memberIdToProcessId.keySet(), true);
-                    if (member == null) {
-                        throw new TaskAssignorException("No member available to assign task " + i + " of subtopology " + subtopologyId);
-                    }
-                    activeMembers[i] = member;
-                    updateActiveTasksAssignments(member, subtopologyId, i);
-                    updateHelpers(member, subtopologyId, i);
-                }
-            }
-        }
-    }
-
-    private void assignStandby(GroupSpec groupSpec, TopologyDescriber topologyDescriber) {
-        final int numStandbyReplicas =
-                groupSpec.assignmentConfigs().isEmpty() ? 0
-                        : Integer.parseInt(groupSpec.assignmentConfigs().get("numStandbyReplicas"));
-
-        Map<String, Set<Integer>> stateFulTasks = new HashMap<>();
-        for (String subtopology : groupSpec.subtopologies()) {
-            stateFulTasks.put(subtopology, topologyDescriber.statefulTaskIds(subtopology));
-        }
-
-        for (Map.Entry<String, Set<Integer>> task : stateFulTasks.entrySet()) {
-            final String subtopologyId = task.getKey();
-            for (int taskId : task.getValue()) {
-                for (int i = 0; i < numStandbyReplicas; i++) {
-                    final Set<String> availableMembers = findMembersWithoutAssignedTask(subtopologyId, taskId);
-                    if (availableMembers.isEmpty()) {
-                        log.warn("Unable to assign " + (numStandbyReplicas - i) +
-                                " of " + numStandbyReplicas+" standby tasks for task [" + taskId + "]. " +
-                                "There is not enough available capacity. You should " +
-                                "increase the number of threads and/or application instances " +
-                                "to maintain the requested number of standby replicas.");
-                        break;
-                    }
-                    final String memberId = findMember(subtopologyId, taskId, availableMembers, false);
-                    if (memberId != null) {
-                        addStandbyTask(memberId, subtopologyId, taskId);
-                    }
-                }
-            }
-        }
-    }
-
-    private String findMember(String subtopologyId, int taskId, Set<String> availableMembers, boolean includePrevs) {
-        String memberId = null;
-        // if one option
-        if (availableMembers.size() == 1) {
-            memberId =  availableMembers.iterator().next();
-        } else {
-            // find prev active or if no relevant active task existing, find prev standby task
-            if (!includePrevs)
-                memberId = findFamiliarMember(subtopologyId, taskId, availableMembers);
-
-            if (memberId != null) {
-                if (shouldBalanceLoad(memberId)) {
-                    final String standby = findPrevStandbyMemberWithLeastLoad(subtopologyId, taskId, availableMembers);
-                    if (standby == null || shouldBalanceLoad(standby)) {
-                        memberId = findMemberWithLeastLoad(availableMembers, subtopologyId, taskId, false);
-                    } else {
-                        memberId = standby;
-                    }
-                }
-            } else {
-                memberId = findMemberWithLeastLoad(availableMembers, subtopologyId, taskId, false);
-            }
-        }
-
-        return memberId;
-    }
-
-    private boolean shouldBalanceLoad(String memberId) {
-        final ProcessSpec processSpec = processIdToProcessSpec.get(memberIdToProcessId.get(memberId));
-        return processSpec.reachedCapacity() && hasNodesWithMoreAvailableCapacity(processSpec.processId());
-    }
-
-    private boolean hasNodesWithMoreAvailableCapacity(String processId) {
-        final ProcessSpec processSpec = processIdToProcessSpec.get(processId);
-        final ProcessSpec minProcessSpec = findProcessWithLeastLoad(processIdToProcessSpec.keySet());
-        return !(Objects.equals(processSpec.processId(), minProcessSpec.processId()));
-    }
-
-    private String findFamiliarMember(String subtopologyId, int taskId, Set<String> availableMembers) {
-        String memberId;
-        final String prevActiveMember = subtopologyToPrevActiveMember.get(subtopologyId)[taskId];
-
-        if (prevActiveMember != null && availableMembers.contains(prevActiveMember)) {
-            memberId = prevActiveMember;
-            // prev standby with least load
-        } else {
-            memberId = findPrevStandbyMemberWithLeastLoad(subtopologyId, taskId, availableMembers);
-        }
-        return memberId;
-    }
-
-    private void addStandbyTask(String memberId, String subtopologyId, int taskId) {
-        // add to standbyTasksAssignments
-        standbyTasksAssignments.putIfAbsent(memberId, new HashMap<>());
-        standbyTasksAssignments.get(memberId).putIfAbsent(subtopologyId, new HashSet<>());
-        standbyTasksAssignments.get(memberId).get(subtopologyId).add(taskId);
-        updateHelpers(memberId, subtopologyId, taskId);
-    }
-
-    private Set<String> findMembersWithoutAssignedTask(String subtopologyId, int taskId) {
-        Set<String> availableMembers = new HashSet<>();
-        for (ProcessSpec processSpec : processIdToProcessSpec.values()) {
-            if (!processSpec.hasTask(subtopologyId, taskId))
-                availableMembers.addAll(processSpec.memberToTaskCounts().keySet());
-        }
-        return availableMembers;
-    }
-
-    private void updateActiveTasksAssignments(String memberId, String subtopologyId, int taskId) {
-        Set<Integer> newSet = new HashSet<>(activeTasksAssignments.get(memberId).getOrDefault(subtopologyId, new HashSet<>()));
-        newSet.add(taskId);
-        activeTasksAssignments.get(memberId).put(subtopologyId, newSet);
-    }
-
-    private void maybeUpdateTasksPerThread(int activeTasksCount) {
-        // update tasksPerThread: explanation
-        if (activeTasksCount == tasksPerThread) {
-            totalCapacity --;
-            allTasks -= activeTasksCount;
-            tasksPerThread = computeTasksPerThread(allTasks, totalCapacity);
-        }
-    }
-
-    private void updateHelpers(String memberId, Map<String, Set<Integer>> tasks) {
-        final String processId = memberIdToProcessId.get(memberId);
-
-        // add the tasks to the corresponding ProcessSpec
-        processIdToProcessSpec.get(processId).addTasks(memberId, tasks);
-
-        // add all pair combinations: update taskPairs
-        addToTaskPairs(tasks);
-
-        // update subtopologyToActiveMember
-        for (Map.Entry<String, Set<Integer>> entry : tasks.entrySet()) {
-            final String subtopologyId = entry.getKey();
-            final Set<Integer> taskIds = entry.getValue();
-            final String[] activeMembers = subtopologyToActiveMember.get(subtopologyId);//new...maybe empty
-            if (activeMembers != null) {
-                for (int taskId : taskIds) {
-                    if (taskId < activeMembers.length) {
-                        if (activeMembers[taskId] != null) {
-                            throw new TaskAssignorException(
-                                    "Task " + taskId + " of subtopology " + subtopologyId + " is assigned to multiple members.");
-                        }
-                        activeMembers[taskId] = memberId;
-                    }
-                }
-            }
-        }
-    }
-
-    private void updateHelpers(String memberId, String subtopologyId, int taskId) {
-        final String processId = memberIdToProcessId.get(memberId);
-
-        // add the tasks to the corresponding ProcessSpec
-        processIdToProcessSpec.get(processId).addTask(memberId, subtopologyId, taskId);
-        // add all pair combinations: update taskPairs
-        addToTaskPairs(memberId, subtopologyId, taskId);
-    }
-
-    private void maybeRemoveExtraTasks(Map<String, Set<Integer>> tasks) {
-        int activeTasksCount = tasks.values().stream().mapToInt(Set::size).sum();
-        if (activeTasksCount > tasksPerThread) {
-            int curActiveTasksCount = 0;
-            for (Map.Entry<String, Set<Integer>> entry : tasks.entrySet()) {
-                int remaining = tasksPerThread - curActiveTasksCount;
-                if (curActiveTasksCount < tasksPerThread) {
-                    entry.setValue(entry.getValue().stream()
-                            .skip(0) // start offset
-                            .limit(Math.min(remaining, entry.getValue().size()))
-                            .collect(Collectors.toSet()));
-                    curActiveTasksCount += entry.getValue().size();
-                } else { // remove the extra tasks
-                    entry.setValue(new HashSet<>());
-                }
-            }
-        }
-    }
-
-    private void addToTaskPairs(String memberId, String subtopologyId, int taskId) {
-        final String processId = memberIdToProcessId.get(memberId);
-        taskPairs.addPairs(new TaskId(subtopologyId, taskId), processIdToProcessSpec.get(processId).assignedTasks());
-    }
-
-    private void addToTaskPairs(Map<String, Set<Integer>> curActiveTasks) {
-        List<TaskId> taskList = new ArrayList<>();
-        for (Map.Entry<String, Set<Integer>> entry : curActiveTasks.entrySet()) {
-            String subtopologyId = entry.getKey();
-            for (Integer id : entry.getValue()) {
-                taskList.add(new TaskId(subtopologyId, id));
-            }
-        }
-
-        for (int i = 1; i < taskList.size(); i++) {
-            taskPairs.addPairs(taskList.get(i - 1), new HashSet<>(taskList.subList(i, taskList.size())));
-        }
-    }
-
-    private int computeTasksPerThread(int allTasks, int totalCapacity) {
-        if (totalCapacity == 0) {
-            return 0;
-        }
-        int tasksPerThread = allTasks / totalCapacity;
-        if (allTasks - (tasksPerThread * totalCapacity) > 0) {
-            tasksPerThread++;
-        }
-        return tasksPerThread;
-    }
-
-    private String findMemberWithLeastLoad(Set<String> members, String subtopologyId, int taskId, boolean isLimited) {
-        Set<String> processes = new HashSet<>();
-        for (String member: members) {
-            processes.add(memberIdToProcessId.get(member));
-        }
-        // find the set of right pairs
-        Set<String> rightPairs = findRightPairs (processes, new TaskId(subtopologyId, taskId));
-        if (rightPairs.isEmpty()) {
-            rightPairs = processes;
-        }
-        ProcessSpec minProcessSpec = findProcessWithLeastLoad (rightPairs);
-
-        if (minProcessSpec.processId() != null) {
-            Set<String> processMembers = minProcessSpec.memberToTaskCounts().keySet();
-            Optional<String> minMember = processMembers.stream()
-                    .min(Comparator.comparingInt(minProcessSpec.memberToTaskCounts()::get));
-            if (isLimited) {
-                return minMember.filter(member -> minProcessSpec.memberToTaskCounts().get(member) + 1 <= tasksPerThread).orElse(null);
-            }
-            return minMember.orElse(null);
-        }
-        return null;
-    }
-
-    private Set<String> findRightPairs(Set<String> processes, TaskId task) {
-        Set<String> rightPairs = new HashSet<>();
-        for (String processId : processes) {
-            final ProcessSpec processSpec = processIdToProcessSpec.get(processId);
-            if (taskPairs.hasNewPair(task, processSpec.assignedTasks())) {
-                rightPairs.add(processId);
-            }
-        }
-        return  rightPairs;
-    }
-
-
-    private ProcessSpec findProcessWithLeastLoad(Set<String> processes) {
-        ProcessSpec minProcessSpec = new ProcessSpec(null);
-        for (String processId : processes) {
-            final ProcessSpec processSpec = processIdToProcessSpec.get(processId);
-            if (minProcessSpec.compareTo(processSpec) >= 0)
-                minProcessSpec = processSpec;
-        }
-        return minProcessSpec;
-    }
-
-
-    private String findPrevStandbyMemberWithLeastLoad(String subtopologyId, int taskId, Set<String> availableMembers) {
-        Set<String> prevStandbyMembers = subtopologyToPrevStandbyMember.get(subtopologyId)[taskId];
-        if (prevStandbyMembers != null) {
-            final HashSet<String> constrainTo = new HashSet<>(prevStandbyMembers);
-            constrainTo.retainAll(availableMembers);
-            return findMemberWithLeastLoad(constrainTo, subtopologyId, taskId, false);
-        }
-        return null;
-    }
-
-
-
-    private static class TaskPairs {
-        private final Set<Pair> pairs;
-        private final int maxPairs;
-
-        TaskPairs(final int maxPairs) {
-            this.maxPairs = maxPairs;
-            this.pairs = new HashSet<>(maxPairs);
-        }
-
-        boolean hasNewPair(final TaskId task1,
-                           final Set<TaskId> taskIds) {
-            if (pairs.size() == maxPairs) {
-                return false;
-            }
-            if (taskIds.size() == 0) {
-                return true;
-            }
-            for (final TaskId taskId : taskIds) {
-                if (!pairs.contains(pair(task1, taskId))) {
-                    return true;
-                }
-            }
-            return false;
-        }
-
-        void addPairs(final TaskId taskId, final Set<TaskId> assigned) {
-            for (final TaskId id : assigned) {
-                if (!id.equals(taskId))
-                    pairs.add(pair(id, taskId));
-            }
-        }
-
-        Pair pair(final TaskId task1, final TaskId task2) {
-            if (task1.compareTo(task2) < 0) {
-                return new Pair(task1, task2);
-            }
-            return new Pair(task2, task1);
-        }
-
-
-        private static class Pair {
-            private final TaskId task1;
-            private final TaskId task2;
-
-            Pair(final TaskId task1, final TaskId task2) {
-                this.task1 = task1;
-                this.task2 = task2;
-            }
-
-            @Override
-            public boolean equals(final Object o) {
-                if (this == o) {
-                    return true;
-                }
-                if (o == null || getClass() != o.getClass()) {
-                    return false;
-                }
-                final Pair pair = (Pair) o;
-                return Objects.equals(task1, pair.task1) &&
-                        Objects.equals(task2, pair.task2);
-            }
-
-            @Override
-            public int hashCode() {
-                return Objects.hash(task1, task2);
-            }
-        }
-    }
-}
diff --git a/group-coordinator/src/main/java/org/apache/kafka/coordinator/group/taskassignor/TaskId.java b/group-coordinator/src/main/java/org/apache/kafka/coordinator/group/taskassignor/TaskId.java
index 4c462e2099..3b828a6041 100644
--- a/group-coordinator/src/main/java/org/apache/kafka/coordinator/group/taskassignor/TaskId.java
+++ b/group-coordinator/src/main/java/org/apache/kafka/coordinator/group/taskassignor/TaskId.java
@@ -63,8 +63,4 @@ public final class TaskId {
             ", partition=" + partition +
             '}';
     }
-
-    public int compareTo (TaskId other) {
-        return this.hashCode() - other.hashCode();
-    }
 }
diff --git a/group-coordinator/src/main/java/org/apache/kafka/coordinator/group/taskassignor/TopologyDescriber.java b/group-coordinator/src/main/java/org/apache/kafka/coordinator/group/taskassignor/TopologyDescriber.java
index f936f12281..f2a28e2cc1 100644
--- a/group-coordinator/src/main/java/org/apache/kafka/coordinator/group/taskassignor/TopologyDescriber.java
+++ b/group-coordinator/src/main/java/org/apache/kafka/coordinator/group/taskassignor/TopologyDescriber.java
@@ -18,9 +18,6 @@ package org.apache.kafka.coordinator.group.taskassignor;
 
 import org.apache.kafka.common.annotation.InterfaceStability;
 
-import java.util.HashSet;
-import java.util.Set;
-
 /**
  * The subscribed topic describer is used by the {@link TaskAssignor} to obtain topic and task metadata of the subscribed topics.
  * <p>
@@ -37,9 +34,4 @@ public interface TopologyDescriber {
      */
     int numPartitions(String subtopologyId);
 
-    default Set<Integer> statefulTaskIds(String subtopologyId) {
-        return new HashSet<>();
-    }
-//    Set<Integer> statefulTaskIds(String subtopologyId);
-
 }
diff --git a/group-coordinator/src/test/java/org/apache/kafka/coordinator/group/streams/TargetAssignmentBuilderTest.java b/group-coordinator/src/test/java/org/apache/kafka/coordinator/group/streams/TargetAssignmentBuilderTest.java
index 5bb51a2aee..03beca5941 100644
--- a/group-coordinator/src/test/java/org/apache/kafka/coordinator/group/streams/TargetAssignmentBuilderTest.java
+++ b/group-coordinator/src/test/java/org/apache/kafka/coordinator/group/streams/TargetAssignmentBuilderTest.java
@@ -213,7 +213,7 @@ public class TargetAssignmentBuilderTest {
             Map<String, Map<Integer, String>> invertedTargetAssignment = TaskAssignmentTestUtil.invertedTargetAssignment(memberSpecs);
 
             // Prepare the expected assignment spec.
-            GroupSpecImpl groupSpec = new GroupSpecImpl(memberSpecs, new ArrayList<>(topology.subtopologies().keySet()), new HashMap<>());
+            GroupSpecImpl groupSpec = new GroupSpecImpl(memberSpecs, new ArrayList<>(topology.subtopologies().keySet()));
 
             // We use `any` here to always return an assignment but use `verify` later on
             // to ensure that the input was correct.
diff --git a/group-coordinator/src/test/java/org/apache/kafka/coordinator/group/taskassignor/GroupSpecImplTest.java b/group-coordinator/src/test/java/org/apache/kafka/coordinator/group/taskassignor/GroupSpecImplTest.java
index 3c6cd3b15e..b9c9a8e7aa 100644
--- a/group-coordinator/src/test/java/org/apache/kafka/coordinator/group/taskassignor/GroupSpecImplTest.java
+++ b/group-coordinator/src/test/java/org/apache/kafka/coordinator/group/taskassignor/GroupSpecImplTest.java
@@ -56,8 +56,7 @@ public class GroupSpecImplTest {
 
         groupSpec = new GroupSpecImpl(
             members,
-            subtopologies,
-                Collections.emptyMap()
+            subtopologies
         );
     }
 
diff --git a/group-coordinator/src/test/java/org/apache/kafka/coordinator/group/taskassignor/MockAssignorTest.java b/group-coordinator/src/test/java/org/apache/kafka/coordinator/group/taskassignor/MockAssignorTest.java
index 2d4d4b3ccd..bc316db877 100644
--- a/group-coordinator/src/test/java/org/apache/kafka/coordinator/group/taskassignor/MockAssignorTest.java
+++ b/group-coordinator/src/test/java/org/apache/kafka/coordinator/group/taskassignor/MockAssignorTest.java
@@ -43,8 +43,7 @@ public class MockAssignorTest {
         final GroupAssignment result = assignor.assign(
             new GroupSpecImpl(
                 Collections.emptyMap(),
-                Collections.emptyList(),
-                Collections.emptyMap()
+                Collections.emptyList()
             ),
             x -> 5
         );
@@ -71,8 +70,7 @@ public class MockAssignorTest {
         final GroupAssignment result = assignor.assign(
             new GroupSpecImpl(
                 Collections.singletonMap("test_member", memberSpec),
-                Collections.singletonList("test-subtopology"),
-                    Collections.emptyMap()
+                Collections.singletonList("test-subtopology")
             ),
             x -> 4
         );
@@ -90,44 +88,44 @@ public class MockAssignorTest {
     public void testTwoMembersTwoSubtopologies() {
 
         final AssignmentMemberSpec memberSpec1 = new AssignmentMemberSpec(
-                Optional.empty(),
-                Optional.empty(),
-                Collections.emptyMap(),
-                Collections.emptyMap(),
-                Collections.emptyMap(),
-                "test-process",
-                Collections.emptyMap(),
-                Collections.emptyMap(),
-                Collections.emptyMap()
+            Optional.empty(),
+            Optional.empty(),
+            Collections.emptyMap(),
+            Collections.emptyMap(),
+            Collections.emptyMap(),
+            "test-process",
+            Collections.emptyMap(),
+            Collections.emptyMap(),
+            Collections.emptyMap()
         );
 
         final AssignmentMemberSpec memberSpec2 = new AssignmentMemberSpec(
-                Optional.empty(),
-                Optional.empty(),
-                Collections.emptyMap(),
-                Collections.emptyMap(),
-                Collections.emptyMap(),
-                "test-process",
-                Collections.emptyMap(),
-                Collections.emptyMap(),
-                Collections.emptyMap()
+            Optional.empty(),
+            Optional.empty(),
+            Collections.emptyMap(),
+            Collections.emptyMap(),
+            Collections.emptyMap(),
+            "test-process",
+            Collections.emptyMap(),
+            Collections.emptyMap(),
+            Collections.emptyMap()
         );
 
         final GroupAssignment result = assignor.assign(
-                new GroupSpecImpl(
-                        mkMap(mkEntry("test_member1", memberSpec1), mkEntry("test_member2", memberSpec2)),
-                        Arrays.asList("test-subtopology1", "test-subtopology2"), Collections.emptyMap()
-                ),
-                x -> 4
+            new GroupSpecImpl(
+                mkMap(mkEntry("test_member1", memberSpec1), mkEntry("test_member2", memberSpec2)),
+                Arrays.asList("test-subtopology1", "test-subtopology2")
+            ),
+            x -> 4
         );
 
         final Map<String, Set<Integer>> expected1 = mkMap(
-                mkEntry("test-subtopology1", mkSet(1, 3)),
-                mkEntry("test-subtopology2", mkSet(1, 3))
+            mkEntry("test-subtopology1", mkSet(1, 3)),
+            mkEntry("test-subtopology2", mkSet(1, 3))
         );
         final Map<String, Set<Integer>> expected2 = mkMap(
-                mkEntry("test-subtopology1", mkSet(0, 2)),
-                mkEntry("test-subtopology2", mkSet(0, 2))
+            mkEntry("test-subtopology1", mkSet(0, 2)),
+            mkEntry("test-subtopology2", mkSet(0, 2))
         );
 
         assertEquals(2, result.members().size());
@@ -174,7 +172,7 @@ public class MockAssignorTest {
         final GroupAssignment result = assignor.assign(
             new GroupSpecImpl(
                 mkMap(mkEntry("test_member1", memberSpec1), mkEntry("test_member2", memberSpec2)),
-                Arrays.asList("test-subtopology1", "test-subtopology2"), Collections.emptyMap()
+                Arrays.asList("test-subtopology1", "test-subtopology2")
             ),
             x -> 4
         );
diff --git a/group-coordinator/src/test/java/org/apache/kafka/coordinator/group/taskassignor/StickyAssignorTest.java b/group-coordinator/src/test/java/org/apache/kafka/coordinator/group/taskassignor/StickyAssignorTest.java
deleted file mode 100644
index cefb69a4f3..0000000000
--- a/group-coordinator/src/test/java/org/apache/kafka/coordinator/group/taskassignor/StickyAssignorTest.java
+++ /dev/null
@@ -1,1268 +0,0 @@
-package org.apache.kafka.coordinator.group.taskassignor;
-
-import org.junit.jupiter.api.Test;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Optional;
-import java.util.Set;
-import java.util.UUID;
-import java.util.stream.Collectors;
-import java.util.stream.Stream;
-
-import static java.util.Arrays.asList;
-import static org.apache.kafka.common.utils.Utils.mkEntry;
-import static org.apache.kafka.common.utils.Utils.mkMap;
-import static org.apache.kafka.common.utils.Utils.mkSet;
-import static org.junit.jupiter.api.Assertions.assertEquals;
-import static org.junit.jupiter.api.Assertions.assertFalse;
-import static org.junit.jupiter.api.Assertions.assertNotEquals;
-import static org.junit.jupiter.api.Assertions.assertNotNull;
-import static org.junit.jupiter.api.Assertions.assertNull;
-import static org.junit.jupiter.api.Assertions.assertTrue;
-public class StickyAssignorTest {
-    private final StickyAssignor assignor = new StickyAssignor(false);
-
-
-    @Test
-    public void shouldAssignOneActiveTaskToEachProcessWhenTaskCountSameAsProcessCount() {
-        final AssignmentMemberSpec memberSpec1 = createAssignmentMemberSpec("process1");
-        final AssignmentMemberSpec memberSpec2 = createAssignmentMemberSpec("process2");
-        final AssignmentMemberSpec memberSpec3 = createAssignmentMemberSpec("process3");
-
-        final GroupAssignment result = assignor.assign(
-                new GroupSpecImpl(
-                        mkMap(mkEntry("member1", memberSpec1), mkEntry("member2", memberSpec2), mkEntry("member3", memberSpec3)),
-                        Collections.singletonList("test-subtopology"),
-                        new HashMap<>()
-                ),
-                x -> 3
-        );
-
-        assertEquals(3, result.members().size());
-        Set<Integer> actualActiveTasks = new HashSet<>();
-        for (int i = 0; i < 3 ; i++) {
-            final MemberAssignment testMember = result.members().get("member" + (i + 1));
-            assertNotNull(testMember);
-            assertEquals(1, testMember.activeTasks().size());
-            actualActiveTasks.addAll(testMember.activeTasks().get("test-subtopology"));
-        }
-        assertEquals(mkSet(0, 1, 2), actualActiveTasks);
-    }
-
-    @Test
-    public void shouldAssignTopicGroupIdEvenlyAcrossClientsWithNoStandByTasks() {
-
-        final AssignmentMemberSpec memberSpec1_1 = createAssignmentMemberSpec("process1");
-        final AssignmentMemberSpec memberSpec1_2 = createAssignmentMemberSpec("process1");
-
-        final AssignmentMemberSpec memberSpec2_1 = createAssignmentMemberSpec("process2");
-        final AssignmentMemberSpec memberSpec2_2 = createAssignmentMemberSpec("process2");
-
-        final AssignmentMemberSpec memberSpec3_1 = createAssignmentMemberSpec("process3");
-        final AssignmentMemberSpec memberSpec3_2 = createAssignmentMemberSpec("process3");
-
-        final Map<String, AssignmentMemberSpec> members = mkMap(mkEntry("member1_1", memberSpec1_1), mkEntry("member1_2", memberSpec1_2),
-                mkEntry("member2_1", memberSpec2_1), mkEntry("member2_2", memberSpec2_2),
-                mkEntry("member3_1", memberSpec3_1), mkEntry("member3_2", memberSpec3_2));
-
-        final GroupAssignment result = assignor.assign(
-                new GroupSpecImpl(members, Arrays.asList("test-subtopology1", "test-subtopology2"), new HashMap<>()),
-                x -> 3
-        );
-
-        assertEquals(1, getAllActiveTaskCount(result, "member1_1"));
-        assertEquals(1, getAllActiveTaskCount(result, "member1_2"));
-        assertEquals(1, getAllActiveTaskCount(result, "member2_1"));
-        assertEquals(1, getAllActiveTaskCount(result, "member2_2"));
-        assertEquals(1, getAllActiveTaskCount(result, "member3_1"));
-        assertEquals(1, getAllActiveTaskCount(result, "member3_2"));
-
-        assertEquals(mkMap(mkEntry("test-subtopology1", mkSet(0, 1, 2)), mkEntry("test-subtopology2", mkSet(0, 1, 2))),
-                mergeAllActiveTasks(result, "member1_1", "member1_2", "member2_1", "member2_2", "member3_1", "member3_2"));
-    }
-
-    @Test
-    public void shouldAssignTopicGroupIdEvenlyAcrossClientsWithStandByTasks() {
-        final Map<String, Set<Integer>> tasks = mkMap(mkEntry("test-subtopology1", mkSet(0, 1, 2)), mkEntry("test-subtopology2", mkSet(0, 1, 2)));
-        final AssignmentMemberSpec memberSpec1_1 = createAssignmentMemberSpec("process1");
-        final AssignmentMemberSpec memberSpec1_2 = createAssignmentMemberSpec("process1");
-
-        final AssignmentMemberSpec memberSpec2_1 = createAssignmentMemberSpec("process2");
-        final AssignmentMemberSpec memberSpec2_2 = createAssignmentMemberSpec("process2");
-
-        final AssignmentMemberSpec memberSpec3_1 = createAssignmentMemberSpec("process3");
-        final AssignmentMemberSpec memberSpec3_2 = createAssignmentMemberSpec("process3");
-
-        final Map<String, AssignmentMemberSpec> members = mkMap(mkEntry("member1_1", memberSpec1_1), mkEntry("member1_2", memberSpec1_2),
-                mkEntry("member2_1", memberSpec2_1), mkEntry("member2_2", memberSpec2_2),
-                mkEntry("member3_1", memberSpec3_1), mkEntry("member3_2", memberSpec3_2));
-
-        final GroupAssignment result = assignor.assign(
-                new GroupSpecImpl(members,
-                        Arrays.asList("test-subtopology1", "test-subtopology2"),
-                        mkMap(mkEntry("numStandbyReplicas", "1"))),
-                new TopologyDescriberImpl(tasks, 3)
-        );
-
-        // active tasks
-        assertEquals(1, getAllActiveTaskCount(result, "member1_1"));
-        assertEquals(1, getAllActiveTaskCount(result, "member1_2"));
-        assertEquals(1, getAllActiveTaskCount(result, "member2_1"));
-        assertEquals(1, getAllActiveTaskCount(result, "member2_2"));
-        assertEquals(1, getAllActiveTaskCount(result, "member3_1"));
-        assertEquals(1, getAllActiveTaskCount(result, "member3_2"));
-        assertEquals(tasks,
-                mergeAllActiveTasks(result, "member1_1", "member1_2", "member2_1", "member2_2", "member3_1", "member3_2"));
-    }
-
-    @Test
-    public void shouldNotMigrateActiveTaskToOtherProcess() {
-        final AssignmentMemberSpec memberSpec1 = createAssignmentMemberSpec("process1", mkMap(mkEntry("test-subtopology", Collections.singleton(0))), Collections.emptyMap());
-        AssignmentMemberSpec memberSpec2 = createAssignmentMemberSpec("process2", mkMap(mkEntry("test-subtopology", Collections.singleton(1))), Collections.emptyMap());
-        Map<String, AssignmentMemberSpec> members = mkMap(mkEntry("member1", memberSpec1), mkEntry("member2", memberSpec2));
-        GroupAssignment result = assignor.assign(
-                new GroupSpecImpl(members, Collections.singletonList("test-subtopology"), new HashMap<>()),
-                x -> 3
-        );
-
-
-        MemberAssignment testMember1 = result.members().get("member1");
-        assertNotNull(testMember1);
-        assertTrue(testMember1.activeTasks().get("test-subtopology").contains(0));
-
-        MemberAssignment testMember2 = result.members().get("member2");
-        assertNotNull(testMember2);
-        assertTrue(testMember2.activeTasks().get("test-subtopology").contains(1));
-
-
-        assertEquals(3,
-                testMember1.activeTasks().get("test-subtopology").size() + testMember2.activeTasks().get("test-subtopology").size());
-
-
-        // flip the previous active tasks assignment around.
-        memberSpec2 = createAssignmentMemberSpec("process2", mkMap(mkEntry("test-subtopology", Collections.singleton(1))), Collections.emptyMap());
-        final AssignmentMemberSpec memberSpec3 = createAssignmentMemberSpec("process1", mkMap(mkEntry("test-subtopology", Collections.singleton(2))), Collections.emptyMap());
-        members = mkMap(mkEntry("member2", memberSpec2), mkEntry("member3", memberSpec3));
-        result = assignor.assign(
-                new GroupSpecImpl(members, Collections.singletonList("test-subtopology"), new HashMap<>()),
-                x -> 3
-        );
-
-
-        testMember2 = result.members().get("member2");
-        assertNotNull(testMember2);
-        assertTrue(testMember2.activeTasks().get("test-subtopology").contains(1));
-
-        MemberAssignment testMember3 = result.members().get("member3");
-        assertNotNull(testMember3);
-        assertTrue(testMember3.activeTasks().get("test-subtopology").contains(2));
-
-
-        assertEquals(3,
-                testMember2.activeTasks().get("test-subtopology").size() + testMember3.activeTasks().get("test-subtopology").size());
-    }
-
-    @Test
-    public void shouldMigrateActiveTasksToNewProcessWithoutChangingAllAssignments() {// ss
-        final AssignmentMemberSpec memberSpec1 = createAssignmentMemberSpec("process1", mkMap(mkEntry("test-subtopology", mkSet(0, 2))), Collections.emptyMap());
-        final AssignmentMemberSpec memberSpec2 = createAssignmentMemberSpec("process2", mkMap(mkEntry("test-subtopology", Collections.singleton(1))), Collections.emptyMap());
-        final AssignmentMemberSpec memberSpec3 = createAssignmentMemberSpec("process3");
-
-        Map<String, AssignmentMemberSpec> members = mkMap(
-                mkEntry("member1", memberSpec1), mkEntry("member2", memberSpec2), mkEntry("member3", memberSpec3));
-
-        GroupAssignment result = assignor.assign(
-                new GroupSpecImpl(members, Collections.singletonList("test-subtopology"), new HashMap<>()),
-                x -> 3
-        );
-
-
-        MemberAssignment testMember1 = result.members().get("member1");
-        assertNotNull(testMember1);
-        assertTrue(testMember1.activeTasks().get("test-subtopology").contains(0) || testMember1.activeTasks().get("test-subtopology").contains(2));
-
-        MemberAssignment testMember2 = result.members().get("member2");
-        assertNotNull(testMember2);
-        assertTrue(testMember2.activeTasks().get("test-subtopology").contains(1));
-
-        MemberAssignment testMember3 = result.members().get("member3");
-        assertNotNull(testMember3);
-        assertTrue(testMember3.activeTasks().get("test-subtopology").contains(2) || testMember3.activeTasks().get("test-subtopology").contains(0));
-
-
-        assertEquals(3,
-                testMember1.activeTasks().get("test-subtopology").size() +
-                        testMember2.activeTasks().get("test-subtopology").size() +
-                        testMember3.activeTasks().get("test-subtopology").size());
-    }
-
-    @Test
-    public void shouldAssignBasedOnCapacity() {
-        final AssignmentMemberSpec memberSpec1 = createAssignmentMemberSpec("process1");
-
-        final AssignmentMemberSpec memberSpec2_1 = createAssignmentMemberSpec("process2");
-        final AssignmentMemberSpec memberSpec2_2 = createAssignmentMemberSpec("process2");
-
-
-        Map<String, AssignmentMemberSpec> members = mkMap(
-                mkEntry("member1", memberSpec1), mkEntry("member2_1", memberSpec2_1), mkEntry("member2_2", memberSpec2_2));
-
-        GroupAssignment result = assignor.assign(
-                new GroupSpecImpl(members, Collections.singletonList("test-subtopology"), new HashMap<>()),
-                x -> 3
-        );
-
-
-        MemberAssignment testMember1 = result.members().get("member1");
-        assertNotNull(testMember1);
-        assertEquals(1, testMember1.activeTasks().get("test-subtopology").size());
-
-        MemberAssignment testMember2_1 = result.members().get("member2_1");
-        assertNotNull(testMember2_1);
-        assertEquals(1, testMember2_1.activeTasks().get("test-subtopology").size());
-
-        MemberAssignment testMember2_2 = result.members().get("member2_2");
-        assertNotNull(testMember2_2);
-        assertEquals(1, testMember2_2.activeTasks().get("test-subtopology").size());
-    }
-
-    @Test
-    public void shouldAssignTasksEvenlyWithUnequalTopicGroupSizes() {
-        final Map<String, Set<Integer>> activeTasks = mkMap(
-                mkEntry("test-subtopology1", mkSet(0, 1, 2, 3, 4, 5)),
-                mkEntry("test-subtopology2", mkSet(0)));
-        final AssignmentMemberSpec memberSpec1 = createAssignmentMemberSpec("process1", activeTasks, Collections.emptyMap());
-        final AssignmentMemberSpec memberSpec2 = createAssignmentMemberSpec("process2");
-
-
-        Map<String, AssignmentMemberSpec> members = mkMap(
-                mkEntry("member1", memberSpec1), mkEntry("member2", memberSpec2));
-        GroupAssignment result = assignor.assign(
-                new GroupSpecImpl(members, Arrays.asList("test-subtopology1", "test-subtopology2"), new HashMap<>()),
-                x -> x.equals("test-subtopology1")? 6 : 1
-        );
-
-        MemberAssignment testMember1 = result.members().get("member1");
-        assertNotNull(testMember1);
-        final Set<Integer> member1_topology1 = testMember1.activeTasks().get("test-subtopology1");
-        final Set<Integer> member1_topology2 = testMember1.activeTasks().get("test-subtopology2");
-        assertEquals(4, member1_topology1.size() + member1_topology2.size());
-
-        MemberAssignment testMember2 = result.members().get("member2");
-        assertNotNull(testMember2);
-        final Set<Integer> member2_topology1 = testMember2.activeTasks().get("test-subtopology1");
-        final Set<Integer> member2_topology2 = testMember2.activeTasks().get("test-subtopology2");
-        assertEquals(3, member2_topology1.size() + member2_topology2.size());
-
-
-        assertEquals(activeTasks, mkMap(
-                mkEntry("test-subtopology1", Stream.concat(member1_topology1.stream(),member2_topology1.stream()).collect(Collectors.toSet())),
-                mkEntry("test-subtopology2", Stream.concat(member1_topology2.stream(),member2_topology2.stream()).collect(Collectors.toSet()))));
-    }
-
-    @Test
-    public void shouldKeepActiveTaskStickinessWhenMoreClientThanActiveTasks() {
-        AssignmentMemberSpec memberSpec1 = createAssignmentMemberSpec("process1", mkMap(mkEntry("test-subtopology", Collections.singleton(0))), Collections.emptyMap());
-        AssignmentMemberSpec memberSpec2 = createAssignmentMemberSpec("process2", mkMap(mkEntry("test-subtopology", Collections.singleton(2))), Collections.emptyMap());
-        AssignmentMemberSpec memberSpec3 = createAssignmentMemberSpec("process3", mkMap(mkEntry("test-subtopology", Collections.singleton(1))), Collections.emptyMap());
-        AssignmentMemberSpec memberSpec4 = createAssignmentMemberSpec("process4");
-        AssignmentMemberSpec memberSpec5 = createAssignmentMemberSpec("process5");
-
-
-        Map<String, AssignmentMemberSpec> members = mkMap(
-                mkEntry("member1", memberSpec1), mkEntry("member2", memberSpec2),
-                mkEntry("member3", memberSpec3), mkEntry("member4", memberSpec4), mkEntry("member5", memberSpec5));
-
-        GroupAssignment result = assignor.assign(
-                new GroupSpecImpl(members, Collections.singletonList("test-subtopology"), new HashMap<>()),
-                x -> 3
-        );
-
-
-        MemberAssignment testMember1 = result.members().get("member1");
-        assertNotNull(testMember1);
-        assertEquals(1, testMember1.activeTasks().get("test-subtopology").size());
-        assertEquals(Collections.singleton(0), testMember1.activeTasks().get("test-subtopology"));
-
-
-        MemberAssignment testMember2 = result.members().get("member2");
-        assertNotNull(testMember2);
-        assertEquals(1, testMember2.activeTasks().get("test-subtopology").size());
-        assertEquals(Collections.singleton(2), testMember2.activeTasks().get("test-subtopology"));
-
-
-        MemberAssignment testMember3 = result.members().get("member3");
-        assertNotNull(testMember3);
-        assertEquals(1, testMember3.activeTasks().get("test-subtopology").size());
-        assertEquals(Collections.singleton(1), testMember3.activeTasks().get("test-subtopology"));
-
-        MemberAssignment testMember4 = result.members().get("member4");
-        assertNotNull(testMember4);
-        assertNull(testMember4.activeTasks().get("test-subtopology"));
-
-        MemberAssignment testMember5 = result.members().get("member5");
-        assertNotNull(testMember5);
-        assertNull(testMember5.activeTasks().get("test-subtopology"));
-
-
-        // change up the assignment and make sure it is still sticky
-        memberSpec1 = createAssignmentMemberSpec("process1");
-        memberSpec2 = createAssignmentMemberSpec("process2", mkMap(mkEntry("test-subtopology", Collections.singleton(0))), Collections.emptyMap());
-        memberSpec3 = createAssignmentMemberSpec("process3");
-        memberSpec4 = createAssignmentMemberSpec("process4", mkMap(mkEntry("test-subtopology", Collections.singleton(2))), Collections.emptyMap());
-        memberSpec5 = createAssignmentMemberSpec("process5", mkMap(mkEntry("test-subtopology", Collections.singleton(1))), Collections.emptyMap());
-
-
-        members = mkMap(
-                mkEntry("member1", memberSpec1), mkEntry("member2", memberSpec2),
-                mkEntry("member3", memberSpec3), mkEntry("member4", memberSpec4), mkEntry("member5", memberSpec5));
-        result = assignor.assign(
-                new GroupSpecImpl(members, Collections.singletonList("test-subtopology"), new HashMap<>()),
-                x -> 3
-        );
-
-        testMember1 = result.members().get("member1");
-        assertNotNull(testMember1);
-        assertNull(testMember1.activeTasks().get("test-subtopology"));
-
-
-        testMember2 = result.members().get("member2");
-        assertNotNull(testMember2);
-        assertEquals(1, testMember2.activeTasks().get("test-subtopology").size());
-        assertEquals(Collections.singleton(0), testMember2.activeTasks().get("test-subtopology"));
-
-
-        testMember3 = result.members().get("member3");
-        assertNotNull(testMember3);
-        assertNull(testMember3.activeTasks().get("test-subtopology"));
-
-        testMember4 = result.members().get("member4");
-        assertNotNull(testMember4);
-        assertEquals(1, testMember4.activeTasks().get("test-subtopology").size());
-        assertEquals(Collections.singleton(2), testMember4.activeTasks().get("test-subtopology"));
-
-        testMember5 = result.members().get("member5");
-        assertNotNull(testMember5);
-        assertEquals(1, testMember5.activeTasks().get("test-subtopology").size());
-        assertEquals(Collections.singleton(1), testMember5.activeTasks().get("test-subtopology"));
-    }
-
-    @Test
-    public void shouldAssignTasksToClientWithPreviousStandbyTasks() {
-        final AssignmentMemberSpec memberSpec1 = createAssignmentMemberSpec("process1", Collections.emptyMap(), mkMap(mkEntry("test-subtopology", Collections.singleton(2))));
-        final AssignmentMemberSpec memberSpec2 = createAssignmentMemberSpec("process2", Collections.emptyMap(), mkMap(mkEntry("test-subtopology", Collections.singleton(1))));
-        final AssignmentMemberSpec memberSpec3 = createAssignmentMemberSpec("process3", Collections.emptyMap(), mkMap(mkEntry("test-subtopology", Collections.singleton(0))));
-
-
-        Map<String, AssignmentMemberSpec> members = mkMap(
-                mkEntry("member1", memberSpec1), mkEntry("member2", memberSpec2), mkEntry("member3", memberSpec3));
-
-        GroupAssignment result = assignor.assign(
-                new GroupSpecImpl(members, Collections.singletonList("test-subtopology"), new HashMap<>()),
-                x -> 3
-        );
-
-
-        MemberAssignment testMember1 = result.members().get("member1");
-        assertNotNull(testMember1);
-        assertEquals(1, testMember1.activeTasks().get("test-subtopology").size());
-        assertEquals(Collections.singleton(2), testMember1.activeTasks().get("test-subtopology"));
-
-
-        MemberAssignment testMember2 = result.members().get("member2");
-        assertNotNull(testMember2);
-        assertEquals(1, testMember2.activeTasks().get("test-subtopology").size());
-        assertEquals(Collections.singleton(1), testMember2.activeTasks().get("test-subtopology"));
-
-
-        MemberAssignment testMember3 = result.members().get("member3");
-        assertNotNull(testMember3);
-        assertEquals(1, testMember3.activeTasks().get("test-subtopology").size());
-        assertEquals(Collections.singleton(0), testMember3.activeTasks().get("test-subtopology"));
-    }
-
-    @Test
-    public void shouldAssignBasedOnCapacityWhenMultipleClientHaveStandbyTasks() {
-        final AssignmentMemberSpec memberSpec1 = createAssignmentMemberSpec("process1",
-                mkMap(mkEntry("test-subtopology", Collections.singleton(0))),
-                        mkMap(mkEntry("test-subtopology", Collections.singleton(1))));
-        final AssignmentMemberSpec memberSpec2_1 = createAssignmentMemberSpec("process2",
-                mkMap(mkEntry("test-subtopology", Collections.singleton(2))),
-                mkMap(mkEntry("test-subtopology", Collections.singleton(1))));
-        final AssignmentMemberSpec memberSpec2_2 = createAssignmentMemberSpec("process2",
-                Collections.emptyMap(), Collections.emptyMap());
-
-        Map<String, AssignmentMemberSpec> members = mkMap(
-                mkEntry("member1", memberSpec1),
-                mkEntry("member2_1", memberSpec2_1), mkEntry("member2_2", memberSpec2_2));
-
-        GroupAssignment result = assignor.assign(
-                new GroupSpecImpl(members, Collections.singletonList("test-subtopology"), new HashMap<>()),
-                x -> 3
-        );
-
-
-        MemberAssignment testMember1 = result.members().get("member1");
-        assertNotNull(testMember1);
-        assertEquals(1, testMember1.activeTasks().get("test-subtopology").size());
-        assertEquals(Collections.singleton(0), testMember1.activeTasks().get("test-subtopology"));
-
-        MemberAssignment testMember2_1 = result.members().get("member2_1");
-        assertNotNull(testMember2_1);
-        assertEquals(1, testMember2_1.activeTasks().get("test-subtopology").size());
-        assertEquals(Collections.singleton(2), testMember2_1.activeTasks().get("test-subtopology"));
-
-        MemberAssignment testMember2_2 = result.members().get("member2_2");
-        assertNotNull(testMember2_2);
-        assertEquals(1, testMember2_2.activeTasks().get("test-subtopology").size());
-        assertEquals(Collections.singleton(1), testMember2_2.activeTasks().get("test-subtopology"));
-    }
-
-    @Test
-    public void shouldAssignStandbyTasksToDifferentClientThanCorrespondingActiveTaskIsAssignedTo() {
-        final Map<String, Set<Integer>> tasks = mkMap(mkEntry("test-subtopology", mkSet(0, 1, 2, 3)));
-        final AssignmentMemberSpec memberSpec1 = createAssignmentMemberSpec("process1", mkMap(mkEntry("test-subtopology", Collections.singleton(0))), Collections.emptyMap());
-        final AssignmentMemberSpec memberSpec2 = createAssignmentMemberSpec("process2", mkMap(mkEntry("test-subtopology", Collections.singleton(1))), Collections.emptyMap());
-        final AssignmentMemberSpec memberSpec3 = createAssignmentMemberSpec("process3", mkMap(mkEntry("test-subtopology", Collections.singleton(2))), Collections.emptyMap());
-        final AssignmentMemberSpec memberSpec4 = createAssignmentMemberSpec("process4", mkMap(mkEntry("test-subtopology", Collections.singleton(3))), Collections.emptyMap());
-
-        Map<String, AssignmentMemberSpec> members = mkMap(
-                mkEntry("member1", memberSpec1), mkEntry("member2", memberSpec2),
-                mkEntry("member3", memberSpec3), mkEntry("member4", memberSpec4));
-
-
-        final GroupAssignment result = assignor.assign(
-                new GroupSpecImpl(members,
-                        Collections.singletonList("test-subtopology"),
-                        mkMap(mkEntry("numStandbyReplicas", "1"))),
-                new TopologyDescriberImpl(tasks, 4)
-        );
-
-
-        final List<Integer> member1TaskIds = getAllStandbyTaskIds(result, "member1");
-        assertFalse(member1TaskIds.contains(0));
-        assertTrue(member1TaskIds.size() <= 2);
-
-        final List<Integer> member2TaskIds = getAllStandbyTaskIds(result, "member2");
-        assertFalse(member2TaskIds.contains(1));
-        assertTrue(member2TaskIds.size() <= 2);
-
-        final List<Integer> member3TaskIds = getAllStandbyTaskIds(result, "member3");
-        assertFalse(member3TaskIds.contains(2));
-        assertTrue(member3TaskIds.size() <= 2);
-
-        final List<Integer> member4TaskIds = getAllStandbyTaskIds(result, "member4");
-        assertFalse(member4TaskIds.contains(3));
-        assertTrue(member4TaskIds.size() <= 2);
-
-
-        int nonEmptyStandbyTaskCount = 0;
-        nonEmptyStandbyTaskCount += member1TaskIds.size() == 0 ? 0 : 1;
-        nonEmptyStandbyTaskCount += member2TaskIds.size() == 0 ? 0 : 1;
-        nonEmptyStandbyTaskCount += member3TaskIds.size() == 0 ? 0 : 1;
-        nonEmptyStandbyTaskCount += member4TaskIds.size() == 0 ? 0 : 1;
-
-        assertTrue(nonEmptyStandbyTaskCount >= 3);
-        assertEquals(tasks, mergeAllStandbyTasks(result));
-
-    }
-
-    @Test
-    public void shouldAssignMultipleReplicasOfStandbyTask() {
-        final Map<String, Set<Integer>> tasks = mkMap(mkEntry("test-subtopology", mkSet(0, 1, 2)));
-        final AssignmentMemberSpec memberSpec1 = createAssignmentMemberSpec("process1", mkMap(mkEntry("test-subtopology", Collections.singleton(0))), Collections.emptyMap());
-        final AssignmentMemberSpec memberSpec2 = createAssignmentMemberSpec("process2", mkMap(mkEntry("test-subtopology", Collections.singleton(1))), Collections.emptyMap());
-        final AssignmentMemberSpec memberSpec3 = createAssignmentMemberSpec("process3", mkMap(mkEntry("test-subtopology", Collections.singleton(2))), Collections.emptyMap());
-
-
-        Map<String, AssignmentMemberSpec> members = mkMap(
-                mkEntry("member1", memberSpec1), mkEntry("member2", memberSpec2),
-                mkEntry("member3", memberSpec3));
-        final GroupAssignment result = assignor.assign(
-                new GroupSpecImpl(members,
-                        Collections.singletonList("test-subtopology"),
-                        mkMap(mkEntry("numStandbyReplicas", "2"))),
-                new TopologyDescriberImpl(tasks, 3)
-        );
-
-
-        assertEquals(mkSet(1, 2), new HashSet<>(getAllStandbyTaskIds(result, "member1")));
-        assertEquals(mkSet(0, 2), new HashSet<>(getAllStandbyTaskIds(result, "member2")));
-        assertEquals(mkSet(0, 1), new HashSet<>(getAllStandbyTaskIds(result, "member3")));
-    }
-
-    @Test
-    public void shouldNotAssignStandbyTaskReplicasWhenNoClientAvailableWithoutHavingTheTaskAssigned() {
-        final Map<String, Set<Integer>> task = mkMap(mkEntry("test-subtopology", mkSet(0)));
-        final AssignmentMemberSpec memberSpec1 = createAssignmentMemberSpec("process1");
-
-
-        Map<String, AssignmentMemberSpec> members = mkMap(
-                mkEntry("member1", memberSpec1));
-        final GroupAssignment result = assignor.assign(
-                new GroupSpecImpl(members,
-                        Collections.singletonList("test-subtopology"),
-                        mkMap(mkEntry("numStandbyReplicas", "1"))),
-                new TopologyDescriberImpl(task, 1)
-        );
-        assertTrue(getAllStandbyTasks(result, "member1").isEmpty());
-    }
-
-    @Test
-    public void shouldAssignActiveAndStandbyTasks() {
-        final Map<String, Set<Integer>> tasks = mkMap(mkEntry("test-subtopology", mkSet(0, 1, 2)));
-
-        final AssignmentMemberSpec memberSpec1 = createAssignmentMemberSpec("process1");
-        final AssignmentMemberSpec memberSpec2 = createAssignmentMemberSpec("process2");
-        final AssignmentMemberSpec memberSpec3 = createAssignmentMemberSpec("process3");
-
-
-        Map<String, AssignmentMemberSpec> members = mkMap(
-                mkEntry("member1", memberSpec1),
-                mkEntry("member2", memberSpec2), mkEntry("member3", memberSpec3));;
-        final GroupAssignment result = assignor.assign(
-                new GroupSpecImpl(members,
-                        Collections.singletonList("test-subtopology"),
-                        mkMap(mkEntry("numStandbyReplicas", "1"))),
-                new TopologyDescriberImpl(tasks, 3)
-        );
-
-
-
-        assertEquals(mkSet(0, 1, 2), new HashSet<>(getAllActiveTaskIds(result)));
-        assertEquals(mkSet(0, 1, 2), new HashSet<>(getAllStandbyTaskIds(result)));
-    }
-
-    @Test
-    public void shouldAssignAtLeastOneTaskToEachClientIfPossible() {
-        final AssignmentMemberSpec memberSpec1_1 = createAssignmentMemberSpec("process1");
-        final AssignmentMemberSpec memberSpec1_2 = createAssignmentMemberSpec("process1");
-        final AssignmentMemberSpec memberSpec1_3 = createAssignmentMemberSpec("process1");
-        final AssignmentMemberSpec memberSpec2 = createAssignmentMemberSpec("process2");
-        final AssignmentMemberSpec memberSpec3 = createAssignmentMemberSpec("process3");
-
-
-        Map<String, AssignmentMemberSpec> members = mkMap(
-                mkEntry("member1_1", memberSpec1_1), mkEntry("member1_2", memberSpec1_2), mkEntry("member1_3", memberSpec1_3),
-                mkEntry("member2", memberSpec2), mkEntry("member3", memberSpec3));
-        GroupAssignment result = assignor.assign(
-                new GroupSpecImpl(members, Collections.singletonList("test-subtopology"), new HashMap<>()),
-                x -> 3
-        );
-
-        assertEquals(1, getAllActiveTaskIds(result, "member1_1", "member1_2", "member1_3").size());
-        assertEquals(1, getAllActiveTaskIds(result, "member2").size());
-        assertEquals(1, getAllActiveTaskIds(result, "member3").size());
-    }
-
-    @Test
-    public void shouldAssignEachActiveTaskToOneClientWhenMoreClientsThanTasks() {
-        final AssignmentMemberSpec memberSpec1 = createAssignmentMemberSpec("process1");
-        final AssignmentMemberSpec memberSpec2 = createAssignmentMemberSpec("process2");
-        final AssignmentMemberSpec memberSpec3 = createAssignmentMemberSpec("process3");
-        final AssignmentMemberSpec memberSpec4 = createAssignmentMemberSpec("process4");
-        final AssignmentMemberSpec memberSpec5 = createAssignmentMemberSpec("process5");
-        final AssignmentMemberSpec memberSpec6 = createAssignmentMemberSpec("process6");
-
-        Map<String, AssignmentMemberSpec> members = mkMap(
-                mkEntry("member1", memberSpec1), mkEntry("member2", memberSpec2), mkEntry("member3", memberSpec3),
-                mkEntry("member4", memberSpec4), mkEntry("member5", memberSpec5), mkEntry("member6", memberSpec6));
-        GroupAssignment result = assignor.assign(
-                new GroupSpecImpl(members, Collections.singletonList("test-subtopology"), new HashMap<>()),
-                x -> 3
-        );
-
-        assertEquals(3, getAllActiveTaskIds(result, "member1", "member2", "member3", "member4", "member5", "member6").size());
-        assertEquals(mkSet(0, 1, 2), getActiveTasks(result, "test-subtopology", "member1", "member2", "member3", "member4", "member5", "member6"));
-    }
-
-    @Test
-    public void shouldBalanceActiveAndStandbyTasksAcrossAvailableClients() {
-        final Map<String, Set<Integer>> tasks = mkMap(mkEntry("test-subtopology", mkSet(0, 1, 2)));
-
-        final AssignmentMemberSpec memberSpec1 = createAssignmentMemberSpec("process1");
-        final AssignmentMemberSpec memberSpec2 = createAssignmentMemberSpec("process2");
-        final AssignmentMemberSpec memberSpec3 = createAssignmentMemberSpec("process3");
-        final AssignmentMemberSpec memberSpec4 = createAssignmentMemberSpec("process4");
-        final AssignmentMemberSpec memberSpec5 = createAssignmentMemberSpec("process5");
-        final AssignmentMemberSpec memberSpec6 = createAssignmentMemberSpec("process6");
-
-        Map<String, AssignmentMemberSpec> members = mkMap(
-                mkEntry("member1", memberSpec1), mkEntry("member2", memberSpec2), mkEntry("member3", memberSpec3),
-                mkEntry("member4", memberSpec4), mkEntry("member5", memberSpec5), mkEntry("member6", memberSpec6));
-
-        final GroupAssignment result = assignor.assign(
-                new GroupSpecImpl(members,
-                        Collections.singletonList("test-subtopology"),
-                        mkMap(mkEntry("numStandbyReplicas", "1"))),
-                new TopologyDescriberImpl(tasks, 3)
-        );
-
-        for (String memberId : result.members().keySet()) {
-            assertEquals(1, getAllStandbyTasks(result, memberId).size() + getAllActiveTaskIds(result, memberId).size());
-
-        }
-    }
-
-    @Test
-    public void shouldAssignMoreTasksToClientWithMoreCapacity() {
-        final AssignmentMemberSpec memberSpec1 = createAssignmentMemberSpec("process1");
-        final AssignmentMemberSpec memberSpec2_1 = createAssignmentMemberSpec("process2");
-        final AssignmentMemberSpec memberSpec2_2 = createAssignmentMemberSpec("process2");
-
-        Map<String, AssignmentMemberSpec> members = mkMap(
-                mkEntry("member1", memberSpec1), mkEntry("member2_1", memberSpec2_1), mkEntry("member2_2", memberSpec2_2));
-        GroupAssignment result = assignor.assign(
-                new GroupSpecImpl(members, Arrays.asList("test-subtopology0", "test-subtopology1", "test-subtopology2", "test-subtopology3"), new HashMap<>()),
-                x -> 3
-        );
-
-        assertEquals(8, getAllActiveTaskCount(result, "member2_1", "member2_2"));
-        assertEquals(4, getAllActiveTaskCount(result, "member1"));
-    }
-
-    @Test//todo rack-aware
-    public void shouldEvenlyDistributeByTaskIdAndPartition() {
-        final AssignmentMemberSpec memberSpec1_1 = createAssignmentMemberSpec("process1");
-        final AssignmentMemberSpec memberSpec1_2 = createAssignmentMemberSpec("process1");
-        final AssignmentMemberSpec memberSpec1_3 = createAssignmentMemberSpec("process1");
-        final AssignmentMemberSpec memberSpec1_4 = createAssignmentMemberSpec("process1");
-
-        final AssignmentMemberSpec memberSpec2_1 = createAssignmentMemberSpec("process2");
-        final AssignmentMemberSpec memberSpec2_2 = createAssignmentMemberSpec("process2");
-        final AssignmentMemberSpec memberSpec2_3 = createAssignmentMemberSpec("process2");
-        final AssignmentMemberSpec memberSpec2_4 = createAssignmentMemberSpec("process2");
-
-        final AssignmentMemberSpec memberSpec3_1 = createAssignmentMemberSpec("process3");
-        final AssignmentMemberSpec memberSpec3_2 = createAssignmentMemberSpec("process3");
-        final AssignmentMemberSpec memberSpec3_3 = createAssignmentMemberSpec("process3");
-        final AssignmentMemberSpec memberSpec3_4 = createAssignmentMemberSpec("process3");
-
-        final AssignmentMemberSpec memberSpec4_1 = createAssignmentMemberSpec("process4");
-        final AssignmentMemberSpec memberSpec4_2 = createAssignmentMemberSpec("process4");
-        final AssignmentMemberSpec memberSpec4_3 = createAssignmentMemberSpec("process4");
-        final AssignmentMemberSpec memberSpec4_4 = createAssignmentMemberSpec("process4");
-
-//        final List<TaskId> taskIds = new ArrayList<>();
-//        final TaskId[] taskIdArray = new TaskId[16];
-//
-//        for (int i = 0; i < 2; i++) {
-//            for (int j = 0; j < 8; j++) {
-//                taskIds.add(new TaskId(i, j));
-//            }
-//        }
-//
-//        Collections.shuffle(taskIds);
-//        taskIds.toArray(taskIdArray);
-
-        Map<String, AssignmentMemberSpec> members = mkMap(
-                mkEntry("member1_1", memberSpec1_1), mkEntry("member1_2", memberSpec1_2), mkEntry("member1_3", memberSpec1_3), mkEntry("member1_4", memberSpec1_4),
-                mkEntry("member2_1", memberSpec2_1), mkEntry("member2_2", memberSpec2_2), mkEntry("member2_3", memberSpec2_3), mkEntry("member2_4", memberSpec2_4),
-                mkEntry("member3_1", memberSpec3_1), mkEntry("member3_2", memberSpec3_2), mkEntry("member3_3", memberSpec3_3), mkEntry("member3_4", memberSpec3_4),
-                mkEntry("member4_1", memberSpec4_1), mkEntry("member4_2", memberSpec4_2), mkEntry("member4_3", memberSpec4_3), mkEntry("member4_4", memberSpec4_4));
-        GroupAssignment result = assignor.assign(
-                new GroupSpecImpl(members, Arrays.asList("test-subtopology0", "test-subtopology1"), new HashMap<>()),
-                x -> 8
-        );
-
-    }
-
-    @Test
-    public void shouldNotHaveSameAssignmentOnAnyTwoHosts() {
-        Map<String, Set<Integer>> tasks = mkMap(mkEntry("test-subtopology", mkSet(0, 2, 1, 3)));
-        final AssignmentMemberSpec memberSpec1 = createAssignmentMemberSpec("process1");
-        final AssignmentMemberSpec memberSpec2 = createAssignmentMemberSpec("process2");
-        final AssignmentMemberSpec memberSpec3 = createAssignmentMemberSpec("process3");
-        final AssignmentMemberSpec memberSpec4 = createAssignmentMemberSpec("process4");
-
-        final List<String> allMemberIds = asList("member1", "member2", "member3", "member4");
-        Map<String, AssignmentMemberSpec> members = mkMap(
-                mkEntry("member1", memberSpec1), mkEntry("member2", memberSpec2), mkEntry("member3", memberSpec3), mkEntry("member4", memberSpec4));
-        final GroupAssignment result = assignor.assign(
-                new GroupSpecImpl(members,
-                        Collections.singletonList("test-subtopology"),
-                        mkMap(mkEntry("numStandbyReplicas", "1"))),
-                new TopologyDescriberImpl(tasks, 4)
-        );
-
-
-        for (final String memberId : allMemberIds) {
-            final List<Integer> taskIds = getAllTaskIds(result, memberId);
-            for (final String otherMemberId : allMemberIds) {
-                if (!memberId.equals(otherMemberId)) {
-                    assertNotEquals(taskIds, getAllTaskIds(result, otherMemberId));
-                }
-            }
-        }
-    }
-
-    @Test
-    public void shouldNotHaveSameAssignmentOnAnyTwoHostsWhenThereArePreviousActiveTasks() {
-        Map<String, Set<Integer>> tasks = mkMap(mkEntry("test-subtopology", mkSet(0, 2, 1, 3)));
-        final AssignmentMemberSpec memberSpec1 = createAssignmentMemberSpec("process1", mkMap(mkEntry("test-subtopology", mkSet(1, 2))), Collections.emptyMap());
-        final AssignmentMemberSpec memberSpec2 = createAssignmentMemberSpec("process2", mkMap(mkEntry("test-subtopology", mkSet(3))), Collections.emptyMap());
-        final AssignmentMemberSpec memberSpec3 = createAssignmentMemberSpec("process3", mkMap(mkEntry("test-subtopology", mkSet(0))), Collections.emptyMap());
-        final AssignmentMemberSpec memberSpec4 = createAssignmentMemberSpec("process4");
-
-        final List<String> allMemberIds = asList("member1", "member2", "member3", "member4");
-        Map<String, AssignmentMemberSpec> members = mkMap(
-                mkEntry("member1", memberSpec1), mkEntry("member2", memberSpec2), mkEntry("member3", memberSpec3), mkEntry("member4", memberSpec4));
-        final GroupAssignment result = assignor.assign(
-                new GroupSpecImpl(members,
-                        Collections.singletonList("test-subtopology"),
-                        mkMap(mkEntry("numStandbyReplicas", "1"))),
-                new TopologyDescriberImpl(tasks, 4)
-        );
-
-
-        for (final String memberId : allMemberIds) {
-            final List<Integer> taskIds = getAllTaskIds(result, memberId);
-            for (final String otherMemberId : allMemberIds) {
-                if (!memberId.equals(otherMemberId)) {
-                    assertNotEquals(taskIds, getAllTaskIds(result, otherMemberId));
-                }
-            }
-        }
-    }
-
-    @Test
-    public void shouldNotHaveSameAssignmentOnAnyTwoHostsWhenThereArePreviousStandbyTasks() {
-        Map<String, Set<Integer>> tasks = mkMap(mkEntry("test-subtopology", mkSet(0, 2, 1, 3)));
-        final AssignmentMemberSpec memberSpec1 = createAssignmentMemberSpec("process1",
-                mkMap(mkEntry("test-subtopology", mkSet(1, 2))),mkMap(mkEntry("test-subtopology", mkSet(3, 0))));
-        final AssignmentMemberSpec memberSpec2 = createAssignmentMemberSpec("process2",
-                mkMap(mkEntry("test-subtopology", mkSet(3, 0))), mkMap(mkEntry("test-subtopology", mkSet(1, 2))));
-        final AssignmentMemberSpec memberSpec3 = createAssignmentMemberSpec("process3");
-        final AssignmentMemberSpec memberSpec4 = createAssignmentMemberSpec("process4");
-
-
-        final List<String> allMemberIds = asList("member1", "member2", "member3", "member4");
-        Map<String, AssignmentMemberSpec> members = mkMap(
-                mkEntry("member1", memberSpec1), mkEntry("member2", memberSpec2), mkEntry("member3", memberSpec3), mkEntry("member4", memberSpec4));
-        final GroupAssignment result = assignor.assign(
-                new GroupSpecImpl(members,
-                        Collections.singletonList("test-subtopology"),
-                        mkMap(mkEntry("numStandbyReplicas", "1"))),
-                new TopologyDescriberImpl(tasks, 4)
-        );
-
-
-        for (final String memberId : allMemberIds) {
-            final List<Integer> taskIds = getAllTaskIds(result, memberId);
-            for (final String otherMemberId : allMemberIds) {
-                if (!memberId.equals(otherMemberId)) {
-                    assertNotEquals(taskIds, getAllTaskIds(result, otherMemberId));
-                }
-            }
-        }
-    }
-
-    @Test
-    public void shouldReBalanceTasksAcrossAllClientsWhenCapacityAndTaskCountTheSame() {
-        final AssignmentMemberSpec memberSpec3 = createAssignmentMemberSpec("process3", mkMap(mkEntry("test-subtopology", mkSet(0, 1, 2, 3))) , Collections.emptyMap());
-        final AssignmentMemberSpec memberSpec1 = createAssignmentMemberSpec("process1");
-        final AssignmentMemberSpec memberSpec2 = createAssignmentMemberSpec("process2");
-        final AssignmentMemberSpec memberSpec4 = createAssignmentMemberSpec("process4");
-
-        Map<String, AssignmentMemberSpec> members = mkMap(
-                mkEntry("member1", memberSpec1), mkEntry("member2", memberSpec2), mkEntry("member3", memberSpec3), mkEntry("member4", memberSpec4));
-        GroupAssignment result = assignor.assign(
-                new GroupSpecImpl(members, Collections.singletonList("test-subtopology"), new HashMap<>()),
-                x -> 4
-        );
-
-        assertEquals(1, getAllActiveTaskCount(result, "member1"));
-        assertEquals(1, getAllActiveTaskCount(result, "member2"));
-        assertEquals(1, getAllActiveTaskCount(result, "member3"));
-        assertEquals(1, getAllActiveTaskCount(result, "member4"));
-    }
-
-    @Test
-    public void shouldReBalanceTasksAcrossClientsWhenCapacityLessThanTaskCount() {
-        final AssignmentMemberSpec memberSpec3 = createAssignmentMemberSpec("process3", mkMap(mkEntry("test-subtopology", mkSet(0, 1, 2, 3))) , Collections.emptyMap());
-        final AssignmentMemberSpec memberSpec1 = createAssignmentMemberSpec("process1");
-        final AssignmentMemberSpec memberSpec2 = createAssignmentMemberSpec("process2");
-
-        Map<String, AssignmentMemberSpec> members = mkMap(
-                mkEntry("member1", memberSpec1), mkEntry("member2", memberSpec2), mkEntry("member3", memberSpec3));
-        GroupAssignment result = assignor.assign(
-                new GroupSpecImpl(members, Collections.singletonList("test-subtopology"), new HashMap<>()),
-                x -> 4
-        );
-
-        assertEquals(1, getAllActiveTaskCount(result, "member1"));
-        assertEquals(1, getAllActiveTaskCount(result, "member2"));
-        assertEquals(2, getAllActiveTaskCount(result, "member3"));
-    }
-
-    @Test
-    public void shouldRebalanceTasksToClientsBasedOnCapacity() {
-        final AssignmentMemberSpec memberSpec2 = createAssignmentMemberSpec("process2", mkMap(mkEntry("test-subtopology", mkSet(0, 3, 2))) , Collections.emptyMap());
-        final AssignmentMemberSpec memberSpec3_1 = createAssignmentMemberSpec("process3");
-        final AssignmentMemberSpec memberSpec3_2 = createAssignmentMemberSpec("process3");
-
-        Map<String, AssignmentMemberSpec> members = mkMap(
-                mkEntry("member2", memberSpec2), mkEntry("member3_1", memberSpec3_1), mkEntry("member3_2", memberSpec3_2));
-        GroupAssignment result = assignor.assign(
-                new GroupSpecImpl(members, Collections.singletonList("test-subtopology"), new HashMap<>()),
-                x -> 3
-        );
-
-        assertEquals(1, getAllActiveTaskCount(result, "member2"));
-        assertEquals(2, getAllActiveTaskCount(result, "member3_1", "member3_2"));
-    }
-
-    @Test
-    public void shouldMoveMinimalNumberOfTasksWhenPreviouslyAboveCapacityAndNewClientAdded() {
-        final Set<Integer> p1PrevTasks = mkSet(0, 2);
-        final Set<Integer> p2PrevTasks = mkSet(1, 3);
-        final AssignmentMemberSpec memberSpec1 = createAssignmentMemberSpec("process1", mkMap(mkEntry("test-subtopology", p1PrevTasks)) , Collections.emptyMap());
-        final AssignmentMemberSpec memberSpec2 = createAssignmentMemberSpec("process2", mkMap(mkEntry("test-subtopology", p2PrevTasks)) , Collections.emptyMap());
-        final AssignmentMemberSpec memberSpec3 = createAssignmentMemberSpec("process3");
-
-        final Map<String, AssignmentMemberSpec> members = mkMap(
-                mkEntry("member1", memberSpec1), mkEntry("member2", memberSpec2), mkEntry("member3", memberSpec3));
-        GroupAssignment result = assignor.assign(
-                new GroupSpecImpl(members, Collections.singletonList("test-subtopology"), new HashMap<>()),
-                x -> 4
-        );
-
-
-
-        assertEquals(1, getAllActiveTaskCount(result, "member3"));
-        final List<Integer> p3ActiveTasks = getAllActiveTaskIds(result, "member3");
-
-        if (p1PrevTasks.removeAll(p3ActiveTasks)) {
-            assertEquals(p2PrevTasks, new HashSet<>(getAllActiveTaskIds(result, "member2")));
-        } else {
-            assertEquals(p1PrevTasks, new HashSet<>(getAllActiveTaskIds(result, "member1")));
-        }
-    }
-
-    @Test
-    public void shouldNotMoveAnyTasksWhenNewTasksAdded() {
-        final AssignmentMemberSpec memberSpec1 = createAssignmentMemberSpec("process1", mkMap(mkEntry("test-subtopology", mkSet(0, 1))) , Collections.emptyMap());
-        final AssignmentMemberSpec memberSpec2 = createAssignmentMemberSpec("process2", mkMap(mkEntry("test-subtopology", mkSet(2, 3))) , Collections.emptyMap());
-
-        final Map<String, AssignmentMemberSpec> members = mkMap(
-                mkEntry("member1", memberSpec1), mkEntry("member2", memberSpec2));
-        GroupAssignment result = assignor.assign(
-                new GroupSpecImpl(members, Collections.singletonList("test-subtopology"), new HashMap<>()),
-                x -> 6
-        );
-
-        final List<Integer> mem1Tasks = getAllActiveTaskIds(result, "member1");
-        assertTrue(mem1Tasks.contains(0));
-        assertTrue(mem1Tasks.contains(1));
-
-        final List<Integer> mem2Tasks = getAllActiveTaskIds(result, "member2");
-        assertTrue(mem2Tasks.contains(2));
-        assertTrue(mem2Tasks.contains(3));
-    }
-
-    @Test
-    public void shouldAssignNewTasksToNewClientWhenPreviousTasksAssignedToOldClients() {
-
-        final AssignmentMemberSpec memberSpec1 = createAssignmentMemberSpec("process1", mkMap(mkEntry("test-subtopology", mkSet(2, 1))) , Collections.emptyMap());
-        final AssignmentMemberSpec memberSpec2 = createAssignmentMemberSpec("process2", mkMap(mkEntry("test-subtopology", mkSet(0, 3))) , Collections.emptyMap());
-        final AssignmentMemberSpec memberSpec3 = createAssignmentMemberSpec("process3");
-
-
-        final Map<String, AssignmentMemberSpec> members = mkMap(
-                mkEntry("member1", memberSpec1), mkEntry("member2", memberSpec2), mkEntry("member3", memberSpec3));
-        GroupAssignment result = assignor.assign(
-                new GroupSpecImpl(members, Collections.singletonList("test-subtopology"), new HashMap<>()),
-                x -> 6
-        );
-
-        final List<Integer> mem1Tasks = getAllActiveTaskIds(result, "member1");
-        assertTrue(mem1Tasks.contains(2));
-        assertTrue(mem1Tasks.contains(1));
-
-        final List<Integer> mem2Tasks = getAllActiveTaskIds(result, "member2");
-        assertTrue(mem2Tasks.contains(0));
-        assertTrue(mem2Tasks.contains(3));
-
-        final List<Integer> mem3Tasks = getAllActiveTaskIds(result, "member3");
-        assertTrue(mem3Tasks.contains(4));
-        assertTrue(mem3Tasks.contains(5));
-    }
-
-    @Test
-    public void shouldAssignTasksNotPreviouslyActiveToNewClient() {
-        final AssignmentMemberSpec memberSpec1 = createAssignmentMemberSpec("process1",
-                mkMap(mkEntry("test-subtopology0", mkSet(1)), mkEntry("test-subtopology1", mkSet(2, 3))),
-                mkMap(mkEntry("test-subtopology0", mkSet(0)), mkEntry("test-subtopology1", mkSet(1)), mkEntry("test-subtopology2", mkSet(0, 1, 3))));
-        final AssignmentMemberSpec memberSpec2 = createAssignmentMemberSpec("process2",
-                mkMap(mkEntry("test-subtopology0", mkSet(0)), mkEntry("test-subtopology1", mkSet(1)), mkEntry("test-subtopology2", mkSet(2))),
-                mkMap(mkEntry("test-subtopology0", mkSet(1, 2, 3)), mkEntry("test-subtopology1", mkSet(0, 2, 3)), mkEntry("test-subtopology2", mkSet(0, 1, 3))));
-        final AssignmentMemberSpec memberSpec3 = createAssignmentMemberSpec("process3",
-                mkMap(mkEntry("test-subtopology2", mkSet(0, 1, 3))),
-                mkMap(mkEntry("test-subtopology0", mkSet(2)), mkEntry("test-subtopology1", mkSet(2))));
-        final AssignmentMemberSpec newMemberSpec = createAssignmentMemberSpec("process4",
-               Collections.emptyMap(),
-                mkMap(mkEntry("test-subtopology0", mkSet(0, 1, 2, 3)), mkEntry("test-subtopology1", mkSet(0, 1, 2, 3)), mkEntry("test-subtopology2", mkSet(0, 1, 2, 3))));
-
-        final Map<String, AssignmentMemberSpec> members = mkMap(
-                mkEntry("member1", memberSpec1), mkEntry("member2", memberSpec2), mkEntry("member3", memberSpec3), mkEntry("newMember", newMemberSpec));
-        GroupAssignment result = assignor.assign(
-                new GroupSpecImpl(members, Arrays.asList("test-subtopology0", "test-subtopology1", "test-subtopology2"), new HashMap<>()),
-                x -> 4
-        );
-        //todo rackaware
-
-        assertEquals(mkMap(mkEntry("test-subtopology0", mkSet(1)), mkEntry("test-subtopology1", mkSet(2, 3))),
-                getAllActiveTasks(result, "member1"));
-        assertEquals(mkMap(mkEntry("test-subtopology0", mkSet(0)), mkEntry("test-subtopology1", mkSet(1)), mkEntry("test-subtopology2", mkSet(2))),
-                getAllActiveTasks(result, "member2"));
-        assertEquals(mkMap(mkEntry("test-subtopology2", mkSet(0, 1, 3))),
-                getAllActiveTasks(result, "member3"));
-        assertEquals(mkMap(mkEntry("test-subtopology0", mkSet(2, 3)), mkEntry("test-subtopology1", mkSet(0))),
-                getAllActiveTasks(result, "newMember"));
-    }
-
-    @Test
-    public void shouldAssignTasksNotPreviouslyActiveToMultipleNewClients() {//c
-        final AssignmentMemberSpec memberSpec1 = createAssignmentMemberSpec("process1",
-                mkMap(mkEntry("test-subtopology0", mkSet(1)), mkEntry("test-subtopology1", mkSet(2, 3))),
-                mkMap(mkEntry("test-subtopology0", mkSet(0)), mkEntry("test-subtopology1", mkSet(1)), mkEntry("test-subtopology2", mkSet(0, 1, 3))));
-        final AssignmentMemberSpec memberSpec2 = createAssignmentMemberSpec("process2",
-                mkMap(mkEntry("test-subtopology0", mkSet(0)), mkEntry("test-subtopology1", mkSet(1)), mkEntry("test-subtopology2", mkSet(2))),
-                mkMap(mkEntry("test-subtopology0", mkSet(1, 2, 3)), mkEntry("test-subtopology1", mkSet(0, 2, 3)), mkEntry("test-subtopology2", mkSet(0, 1, 3))));
-
-
-        final AssignmentMemberSpec bounce1 = createAssignmentMemberSpec("bounce1",
-                Collections.emptyMap(),
-                mkMap(mkEntry("test-subtopology2", mkSet(0, 1, 3))));
-
-
-        final AssignmentMemberSpec bounce2 = createAssignmentMemberSpec("bounce2",
-                Collections.emptyMap(),
-                mkMap(mkEntry("test-subtopology0", mkSet(2, 3)), mkEntry("test-subtopology1", mkSet(0))));
-
-
-
-        final Map<String, AssignmentMemberSpec> members = mkMap(
-                mkEntry("member1", memberSpec1), mkEntry("member2", memberSpec2), mkEntry("bounce_member1", bounce1), mkEntry("bounce_member2", bounce2));
-        GroupAssignment result = assignor.assign(
-                new GroupSpecImpl(members, Arrays.asList("test-subtopology0", "test-subtopology1", "test-subtopology2"), new HashMap<>()),
-                x -> 4
-        );
-
-        //todo rack-aware
-
-
-
-        assertEquals(mkMap(mkEntry("test-subtopology0", mkSet(1)), mkEntry("test-subtopology1", mkSet(2, 3))),
-                getAllActiveTasks(result, "member1"));
-        assertEquals(mkMap(mkEntry("test-subtopology0", mkSet(0)), mkEntry("test-subtopology1", mkSet(1)), mkEntry("test-subtopology2", mkSet(2))),
-                getAllActiveTasks(result, "member2"));
-        assertEquals(mkMap(mkEntry("test-subtopology2", mkSet(0, 1, 3))),
-                getAllActiveTasks(result, "bounce_member1"));
-        assertEquals(mkMap(mkEntry("test-subtopology0", mkSet(2, 3)), mkEntry("test-subtopology1", mkSet(0))),
-                getAllActiveTasks(result, "bounce_member2"));
-    }
-
-    @Test
-    public void shouldAssignTasksToNewClient() {
-        final AssignmentMemberSpec memberSpec1 = createAssignmentMemberSpec("process1", mkMap(mkEntry("test-subtopology", mkSet(1, 2))), Collections.emptyMap());
-        final AssignmentMemberSpec memberSpec2 = createAssignmentMemberSpec("process2");
-
-        final Map<String, AssignmentMemberSpec> members = mkMap(
-                mkEntry("member1", memberSpec1), mkEntry("member2", memberSpec2));
-        GroupAssignment result = assignor.assign(
-                new GroupSpecImpl(members, Collections.singletonList("test-subtopology"), new HashMap<>()),
-                x -> 2
-        );
-
-        assertEquals(1, getAllActiveTaskCount(result, "member1"));
-    }
-
-    @Test
-    public void shouldAssignTasksToNewClientWithoutFlippingAssignmentBetweenExistingClients() {
-        final AssignmentMemberSpec memberSpec1 = createAssignmentMemberSpec("process1", mkMap(mkEntry("test-subtopology", mkSet(0, 1, 2))), Collections.emptyMap());
-        final AssignmentMemberSpec memberSpec2 = createAssignmentMemberSpec("process2", mkMap(mkEntry("test-subtopology", mkSet(3, 4, 5))), Collections.emptyMap());
-        final AssignmentMemberSpec newMemberSpec = createAssignmentMemberSpec("process3");
-
-        final Map<String, AssignmentMemberSpec> members = mkMap(
-                mkEntry("member1", memberSpec1), mkEntry("member2", memberSpec2), mkEntry("newMember", newMemberSpec));
-        GroupAssignment result = assignor.assign(
-                new GroupSpecImpl(members, Collections.singletonList("test-subtopology"), new HashMap<>()),
-                x -> 6
-        );
-
-        final List<Integer> mem1Tasks = getAllActiveTaskIds(result, "member1");
-        assertFalse(mem1Tasks.contains(3));
-        assertFalse(mem1Tasks.contains(4));
-        assertFalse(mem1Tasks.contains(5));
-        assertEquals(2, mem1Tasks.size());
-
-        final List<Integer> mem2Tasks = getAllActiveTaskIds(result, "member2");
-        assertFalse(mem2Tasks.contains(0));
-        assertFalse(mem2Tasks.contains(1));
-        assertFalse(mem2Tasks.contains(2));
-        assertEquals(2, mem2Tasks.size());
-
-        assertEquals(2, getAllActiveTaskIds(result, "newMember").size());
-    }
-
-    @Test
-    public void shouldAssignTasksToNewClientWithoutFlippingAssignmentBetweenExistingAndBouncedClients() {
-        final AssignmentMemberSpec memberSpec1 = createAssignmentMemberSpec("process1", mkMap(mkEntry("test-subtopology", mkSet(0, 1, 2, 6))), Collections.emptyMap());
-        final AssignmentMemberSpec memberSpec2 = createAssignmentMemberSpec("process2", Collections.emptyMap(), mkMap(mkEntry("test-subtopology", mkSet(3, 4, 5))));
-        final AssignmentMemberSpec newMemberSpec = createAssignmentMemberSpec("newProcess");
-
-        final Map<String, AssignmentMemberSpec> members = mkMap(
-                mkEntry("member1", memberSpec1), mkEntry("member2", memberSpec2), mkEntry("newMember", newMemberSpec));
-        GroupAssignment result = assignor.assign(
-                new GroupSpecImpl(members, Collections.singletonList("test-subtopology"), new HashMap<>()),
-                x -> 7
-        );
-
-        final List<Integer> mem1Tasks = getAllActiveTaskIds(result, "member1");
-        assertFalse(mem1Tasks.contains(3));
-        assertFalse(mem1Tasks.contains(4));
-        assertFalse(mem1Tasks.contains(5));
-        assertEquals(3, mem1Tasks.size());
-
-        final List<Integer> mem2Tasks = getAllActiveTaskIds(result, "member2");
-        assertFalse(mem2Tasks.contains(0));
-        assertFalse(mem2Tasks.contains(1));
-        assertFalse(mem2Tasks.contains(2));
-        assertEquals(2, mem2Tasks.size());
-
-        assertEquals(2, getAllActiveTaskIds(result, "newMember").size());
-    }
-
-    @Test//todo rack aware
-    public void shouldViolateBalanceToPreserveActiveTaskStickiness() {
-        final AssignmentMemberSpec memberSpec1 = createAssignmentMemberSpec("process1", mkMap(mkEntry("test-subtopology", mkSet(0, 1, 2))), Collections.emptyMap());
-        final AssignmentMemberSpec memberSpec2 = createAssignmentMemberSpec("process2");
-    }
-
-    @Test//todo rack aware
-    public void shouldOptimizeStatefulAndStatelessTaskTraffic() {}
-
-    @Test//todo rack aware
-    public void shouldAssignRandomInput() {}
-
-    @Test//todo rack aware
-    public void shouldRemainOriginalAssignmentWithoutTrafficCostForMinCostStrategy() {}
-
-
-
-
-
-
-
-
-
-
-    private int getAllActiveTaskCount(GroupAssignment result, String... memberIds) {
-        int size = 0;
-        for (String memberId : memberIds) {
-            final MemberAssignment testMember = result.members().get(memberId);
-            assertNotNull(testMember);
-            assertNotNull(testMember.activeTasks());
-            if(testMember.activeTasks().size() != 0) {
-                for (Map.Entry<String, Set<Integer>> entry : testMember.activeTasks().entrySet()) {
-                    size += entry.getValue().size();
-                }
-            }
-        }
-        return size;
-    }
-
-    private Set<Integer> getActiveTasks(GroupAssignment result, final String topologyId, String... memberIds) {
-        Set<Integer> res = new HashSet<>();
-        for (String memberId : memberIds) {
-            final MemberAssignment testMember = result.members().get(memberId);
-            assertNotNull(testMember);
-            assertNotNull(testMember.activeTasks());
-            if(testMember.activeTasks().get(topologyId)!= null) {
-                res.addAll(testMember.activeTasks().get(topologyId));
-            }
-        }
-        return res;
-    }
-
-    private List<Integer> getAllActiveTaskIds(GroupAssignment result, String... memberIds) {
-        List<Integer> res = new ArrayList<>();
-        for (String memberId : memberIds) {
-            final MemberAssignment testMember = result.members().get(memberId);
-            assertNotNull(testMember);
-            assertNotNull(testMember.activeTasks());
-            if(testMember.activeTasks().size() != 0) {
-                for (Map.Entry<String, Set<Integer>> entry : testMember.activeTasks().entrySet()) {
-                    res.addAll(entry.getValue());
-                }
-            }
-        }
-        return res;
-    }
-
-    private List<Integer> getAllActiveTaskIds(GroupAssignment result) {
-        String[] memberIds = new String[result.members().size()];
-        return getAllActiveTaskIds(result, result.members().keySet().toArray(memberIds));
-    }
-
-    private Map<String, Set<Integer>> getAllActiveTasks(GroupAssignment result, String memberId) {
-
-        final MemberAssignment testMember = result.members().get(memberId);
-        assertNotNull(testMember);
-        assertNotNull(testMember.activeTasks());
-        if(testMember.activeTasks().size() != 0) {
-            return testMember.activeTasks();
-        }
-        return new HashMap<>();
-    }
-
-    private Map<String, Set<Integer>> getAllStandbyTasks(GroupAssignment result, String memberId) {
-
-        final MemberAssignment testMember = result.members().get(memberId);
-        assertNotNull(testMember);
-        assertNotNull(testMember.standbyTasks());
-        if(testMember.standbyTasks().size() != 0) {
-            return testMember.standbyTasks();
-        }
-        return new HashMap<>();
-    }
-
-    private List<Integer> getAllStandbyTaskIds(GroupAssignment result, String... memberIds) {
-        List<Integer> res = new ArrayList<>();
-        for (String memberId : memberIds) {
-            final MemberAssignment testMember = result.members().get(memberId);
-            assertNotNull(testMember);
-            assertNotNull(testMember.standbyTasks());
-            if(testMember.standbyTasks().size() != 0) {
-                for (Map.Entry<String, Set<Integer>> entry : testMember.standbyTasks().entrySet()) {
-                    res.addAll(entry.getValue());
-                }
-            }
-        }
-        return res;
-    }
-
-    private List<Integer> getAllStandbyTaskIds(GroupAssignment result) {
-        String[] memberIds = new String[result.members().size()];
-        return getAllStandbyTaskIds(result, result.members().keySet().toArray(memberIds));
-    }
-
-    private Map<String, Set<Integer>> mergeAllActiveTasks(GroupAssignment result, String... memberIds) {
-        Map<String, Set<Integer>> res = new HashMap<>();
-        for (String memberId : memberIds) {
-            Map<String, Set<Integer>> memberActiveTasks = getAllActiveTasks(result, memberId);
-            res = Stream.of(res, memberActiveTasks)
-                    .flatMap(map -> map.entrySet().stream())
-                    .collect(Collectors.toMap(
-                            Map.Entry::getKey,
-                            Map.Entry::getValue,
-                            (v1, v2) -> {
-                                v1.addAll(v2);
-                                return new HashSet<>(v1);
-                            }));
-
-
-        }
-        return res;
-    }
-
-    private List<Integer> getAllTaskIds(GroupAssignment result, String... memberIds) {
-        List<Integer> res = new ArrayList<>();
-        res.addAll(getAllActiveTaskIds(result, memberIds));
-        res.addAll(getAllStandbyTaskIds(result, memberIds));
-        return res;
-    }
-
-    private Map<String, Set<Integer>> mergeAllStandbyTasks(GroupAssignment result, String... memberIds) {
-        Map<String, Set<Integer>> res = new HashMap<>();
-        for (String memberId : memberIds) {
-            Map<String, Set<Integer>> memberStandbyTasks = getAllStandbyTasks(result, memberId);
-            res = Stream.of(res, memberStandbyTasks)
-                    .flatMap(map -> map.entrySet().stream())
-                    .collect(Collectors.toMap(
-                            Map.Entry::getKey,
-                            Map.Entry::getValue,
-                            (v1, v2) -> {
-                                v1.addAll(v2);
-                                return new HashSet<>(v1);
-                            }));
-
-
-        }
-        return res;
-    }
-    private Map<String, Set<Integer>> mergeAllStandbyTasks(GroupAssignment result) {
-        String[] memberIds = new String[result.members().size()];
-        return mergeAllStandbyTasks(result, result.members().keySet().toArray(memberIds));
-    }
-
-    private List<Integer> getAllTasks(GroupAssignment result, final String topologyId, String... memberIds) {
-        List<Integer> res = new ArrayList<>();
-        for (String memberId : memberIds) {
-            final MemberAssignment testMember = result.members().get(memberId);
-            assertNotNull(testMember);
-            assertNotNull(testMember.activeTasks());
-            if(testMember.activeTasks().get(topologyId)!= null) {
-                res.addAll(testMember.activeTasks().get(topologyId));
-            }
-        }
-        return res;
-    }
-
-
-    private AssignmentMemberSpec createAssignmentMemberSpec(final String processId) {
-        return new AssignmentMemberSpec(
-                Optional.empty(),
-                Optional.empty(),
-                Collections.emptyMap(),
-                Collections.emptyMap(),
-                Collections.emptyMap(),
-                processId,
-                Collections.emptyMap(),
-                Collections.emptyMap(),
-                Collections.emptyMap()
-        );
-    }
-
-    private AssignmentMemberSpec createAssignmentMemberSpec(final String processId, final Map<String, Set<Integer>> prevActiveTasks, final Map<String, Set<Integer>> prevStandbyTasks) {
-        return new AssignmentMemberSpec(
-                Optional.empty(),
-                Optional.empty(),
-                prevActiveTasks,
-                prevStandbyTasks,
-                Collections.emptyMap(),
-                processId,
-                Collections.emptyMap(),
-                Collections.emptyMap(),
-                Collections.emptyMap()
-        );
-    }
-
-    class TopologyDescriberImpl implements TopologyDescriber {
-        final private Map<String, Set<Integer>> statefulTasks;
-        final int numPartitions;
-
-        TopologyDescriberImpl(Map<String, Set<Integer>> statefulTasks, int numPartitions) {
-            this.statefulTasks = statefulTasks;
-            this.numPartitions = numPartitions;
-        }
-
-
-        @Override
-        public int numPartitions(String subtopologyId) {
-            return numPartitions;
-        }
-
-        @Override
-        public Set<Integer> statefulTaskIds(String subtopologyId) {
-            return statefulTasks.get(subtopologyId);
-        }
-    }
-}
